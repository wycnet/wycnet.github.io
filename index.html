<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>wycBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="wycBlog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="wycBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wycBlog">
  
    <link rel="alternate" href="/atom.xml" title="wycBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wycBlog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-csdn转移/js对象" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/js对象/" class="article-date">
  <time datetime="2019-04-28T12:31:54.521Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>@[toc]</p>
<h1 id="实例对象与new命令"><a href="#实例对象与new命令" class="headerlink" title="实例对象与new命令"></a>实例对象与new命令</h1><h2 id="什么是对象"><a href="#什么是对象" class="headerlink" title="什么是对象"></a>什么是对象</h2><p>面向对象OOP是目前主流的编程范式，它将真实世界的复杂关系抽象为一个对象，然后由对象之间的分工合作完成对真实世界的模拟。</p>
<ol>
<li>对象是单个实物的抽象</li>
<li>对象是一个容器，封装了属性和方法</li>
</ol>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>OOP编程首先生成对象。对于传统的面向对象语言C++和java，他们都有<code>类</code>的概念，通过类来生成对象。而在js中却不是这样基于类的，它是基于构造函数(constructor)和原型链(prototype).</p>
<p>js中使用构造函数作为对象的模版，描述实例对象的基本看结构. 一个构造函数可以生成多个实例对象,这些实例对象都有相同的结构. </p>
<p>构造函数仅仅是一个普通的函数,有自己的特征和用法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vec = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述代码中的<code>Vec</code>函数既是一个构造函数, 一般习惯上将构造函数的第一个字母大写.</p>
<p>构造函数的特征点有两个</p>
<pre><code>- 函数内部的`this    `关键字,代表了所要生产的对象实例
- 生成对象时候必须使用`new`命令
</code></pre><h2 id="new命令"><a href="#new命令" class="headerlink" title="new命令"></a>new命令</h2><h3 id="new-命令用于执行构造"><a href="#new-命令用于执行构造" class="headerlink" title="new 命令用于执行构造"></a>new 命令用于执行构造</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vec = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vec();</span><br><span class="line">v.price <span class="comment">//1000</span></span><br></pre></td></tr></table></figure>
<p>构造函数也可以接受参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params">p</span>) </span>&#123;</span><br><span class="line"> 		<span class="keyword">this</span>.price = p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> v = <span class="keyword">new</span> Vehicle(<span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<p>如果忘记使用<code>new</code>,那么构造变成了普通的函数调用,而构造函数中的<code>this`</code>指代全局对象, 所以在构造函数时忘记使用<code>new</code> 将是一件很危险的事情.</p>
<p><strong><em> 为了保证构造函数必须与new命令一起使用, 我们可以使用严格模式,在改模式下忘记使用<code>new</code> 编译器会报错. </em></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Funca</span>(<span class="params">foo,bar</span>)</span>&#123;</span><br><span class="line"><span class="meta">	'use strict'</span>;</span><br><span class="line">	<span class="keyword">this</span>._foo = foo;</span><br><span class="line">	<span class="keyword">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fua = Funca(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>另一个解决办法，构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Fubar</span>(<span class="params">foo, bar</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> Fubar)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>._foo = foo;</span><br><span class="line">  <span class="keyword">this</span>._bar = bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar(<span class="number">1</span>, <span class="number">2</span>)._foo <span class="comment">// 1</span></span><br><span class="line">(<span class="keyword">new</span> Fubar(<span class="number">1</span>, <span class="number">2</span>))._foo <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="new命令的原理"><a href="#new命令的原理" class="headerlink" title="new命令的原理"></a>new命令的原理</h3><p><code>new</code>命令会执行一下步骤.</p>
<pre><code>1. 创建一个空对象,作为将要返回对象的实例.
2. 将这个空对象的原型, 指向构造函数prototype属性
3. 将这个空对象赋值给函数内部的`this`指针
4. 开始执行构造函数内部的代码
</code></pre><p>如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Vehicle = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.price = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1000</span>; <span class="comment">// 在使用该构造时会忽略掉改语句,返回`this`</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> Vehicle()) === <span class="number">1000</span></span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMessage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'this is a message'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> msg = <span class="keyword">new</span> getMessage();</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// &#123;&#125;</span></span><br><span class="line"><span class="keyword">typeof</span> msg <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure>
<h3 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h3><p>函数内部可以使用<code>new.target</code> 属性. 如果当前函数是<code>new</code>命令调用,<code>new.target</code>指向当前函数,否则为undefined</p>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模版生成实例对象. 我们可以根据现有对象来创建一个对象.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">	name:<span class="string">'张三'</span> ,</span><br><span class="line">	age:<span class="number">38</span>,</span><br><span class="line">	greeting: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="built_in">console</span>.log(<span class="string">'Hi! I\'m '</span> + <span class="keyword">this</span>.name+ <span class="string">'.'</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="built_in">Object</span>.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name</span><br><span class="line">person2.greeting()</span><br></pre></td></tr></table></figure>
<h1 id="this-关键字"><a href="#this-关键字" class="headerlink" title="this 关键字"></a>this 关键字</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><p>简单说，this就是属性或方法“当前”所在的对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.property</span><br><span class="line"><span class="comment">// 当前对象的property属性</span></span><br></pre></td></tr></table></figure>
<p>js语言之中,一切皆为对象,运行环境也是对象,所以函数都是在某个对象中运行,<code>this</code>就是函数运行是所在的对象. js中<code>this</code>的指向是动态的,没有办法事先确定到底指向哪个对象.</p>
<h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><p>js中原始对象是以字典结构保存,每一个属性名都对应一个属性描述对象.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">foo</span>: <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//以上对象中的foo属性实际上是以下面的形式保存</span></span><br><span class="line">&#123;</span><br><span class="line">	foo: &#123;</span><br><span class="line">		[[value]]:<span class="number">5</span></span><br><span class="line">		[[writable]]:<span class="literal">true</span></span><br><span class="line">		[[enumberable]]:<span class="literal">true</span></span><br><span class="line">		[[configurable]]:<span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当属性的值为函数时,引擎会将函数单独保存在内存中,然后将函数的地址赋值给foo属性的value属性.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">	foo : &#123;</span><br><span class="line">		[[value]]: 函数地址</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于函数是一个单独的值,所以它可以在不同环境执行. 如果想要执行当前环境中的变量,那么需要使用<code>this</code>关键字:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h2><h3 id="全局环境"><a href="#全局环境" class="headerlink" title="全局环境"></a>全局环境</h3><p>全局使用<code>this</code>, 他指的是顶层对象<code>window</code> .</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> === <span class="built_in">window</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);</span><br><span class="line">&#125;</span><br><span class="line">f(); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数中的<code>this</code> 指的是实例对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Obj = <span class="function"><span class="keyword">function</span>(<span class="params">p</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.p = p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><p>如果对象的方法里包含<code>this</code>,<code>this</code>的指向就是方法运行时所在的对象. 该方法给另一个对象就会改变<code>this</code>的指向. </p>
<h2 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h2><h3 id="避免多层this"><a href="#避免多层this" class="headerlink" title="避免多层this"></a>避免多层<code>this</code></h3><h3 id="避免数组处理方法中的this"><a href="#避免数组处理方法中的this" class="headerlink" title="避免数组处理方法中的this"></a>避免数组处理方法中的<code>this</code></h3><p>数组的map和foreach方法，允许提供一个函数作为参数。这个函数内部不应该使用this。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  v: <span class="string">'hello'</span>,</span><br><span class="line">  p: [ <span class="string">'a1'</span>, <span class="string">'a2'</span> ],</span><br><span class="line">  f: <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.p.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.v + <span class="string">' '</span> + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line"><span class="comment">// undefined a1</span></span><br><span class="line"><span class="comment">// undefined a2</span></span><br></pre></td></tr></table></figure>
<p>foreach方法的回调函数中的<code>this</code>指代的是<code>window</code>对象. ***内层<code>this</code>不指向外层,而是指向顶层的window对象.</p>
<p>解决方法有两种</p>
<ol>
<li>使用中间变量固定</li>
<li>将this当做foreach的第二个参数.</li>
</ol>
<h3 id="避免回调函数中使用this"><a href="#避免回调函数中使用this" class="headerlink" title="避免回调函数中使用this"></a>避免回调函数中使用<code>this</code></h3><p>回调函数中的this往往会改变指向, 最好避免使用.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>() ;</span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery的写法</span></span><br><span class="line">$(<span class="string">'#button'</span>).on(<span class="string">'click'</span>, o.f);</span><br></pre></td></tr></table></figure>
<p>点击按钮以后,控制台会显示<code>false</code>. 原因是此时<code>this</code>不再指向<code>o</code> 对象, 而是指向按钮对象. ***为了解决这个问题,可以对this进行绑定.</p>
<h2 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定<code>this</code>的方法</h2><p><code>this</code>的动态切换, 固然为Javasscript创造了灵活性.  有时, 需要把<code>this</code>固定下来, 避免出现意想不到的情况.<br>js中提供了<code>call</code> , <code>apply</code>, <code>bind</code> 这三个方法,来固定和切换<code>this</code>指针. </p>
<h3 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h3><p>函数实例的<code>call`</code>方法,可以指定函数内部的    <code>this</code>的指向 (即函数执行时所在的域),然后在指定的作用于中调用改函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br><span class="line">f() === <span class="built_in">window</span> <span class="comment">//true</span></span><br><span class="line">f.call(obj) === obj <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>上述代码中,<code>call</code>方法可以改变<code>this</code>的指向为<code>obj</code>, 然后在对象<code>obj</code>的作用域中运行函数<code>f</code></p>
<p><code>call</code> 方法的参数应该是一个对象,如果为空, <code>null</code>  或  <code>undefined</code> , 则默认传入全局对象.</p>
<p><strong>call的第一个参数就是this所要指向的那个对象，后面的参数则是函数调用时所需的参数</strong></p>
<p>call方法可以调用对象的原生方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 覆盖掉继承的hasOwnProperty()方法</span></span><br><span class="line">obj.hasOwnProperty = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.protopype.hasOwnProperty.call(obj,<span class="string">'toString'</span>) <span class="comment">//false</span></span><br><span class="line"><span class="comment">// 将hasOwnProperty方法的原始定义放到obj对象上执行,这样无论`obj`对象上是否有同名方法,都不会影响结果.</span></span><br></pre></td></tr></table></figure>
<h3 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h3><p>apply() 方法的作用与call方法类似, 也是改变<code>this</code>指向,然后再调用该函数. 他们的区别是,它接受一个数组作为函数的参数.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisValue, [arg1,arg2,arg3,...] )</span><br></pre></td></tr></table></figure></p>
<p>利用apply()函数的特性, 可以做一些有趣的事情.</p>
<h4 id="找出数组中的最大元素"><a href="#找出数组中的最大元素" class="headerlink" title="找出数组中的最大元素"></a>找出数组中的最大元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">15</span>,<span class="number">9</span>];</span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>,a) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>
<h4 id="将数组的空元素变成undefined"><a href="#将数组的空元素变成undefined" class="headerlink" title="将数组的空元素变成undefined"></a>将数组的空元素变成<code>undefined</code></h4><p>通过apply()方法,利用Array的构造函数将数组的空元素变成<code>undefined</code> .<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.apply(<span class="literal">null</span>, [<span class="string">'a'</span>, ,<span class="string">'b'</span>])</span><br><span class="line"><span class="comment">// [ 'a', undefined, 'b' ]</span></span><br></pre></td></tr></table></figure></p>
<p>空元素与undefined的差别在于，数组的forEach方法会跳过空元素，但是不会跳过undefined。</p>
<h4 id="转换类似数组的对象"><a href="#转换类似数组的对象" class="headerlink" title="转换类似数组的对象"></a>转换类似数组的对象</h4><p>另外，利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="attr">length</span>:<span class="number">1</span>&#125;)  <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>:<span class="number">1</span>&#125;)  <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="number">0</span>:<span class="number">1</span>, <span class="attr">length</span>:<span class="number">2</span>&#125;)  <span class="comment">// [1,undefined]</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.slice.apply(&#123;<span class="attr">length</span>: <span class="number">1</span>&#125;) <span class="comment">// [undefined]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的apply方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有length属性，以及相对应的数字键。</p>
<h4 id="绑定回调函数的对象"><a href="#绑定回调函数的对象" class="headerlink" title="绑定回调函数的对象"></a>绑定回调函数的对象</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line">o.f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span> === o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  <span class="comment">// 或者 o.f.call(o);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery 的写法</span></span><br><span class="line">$(<span class="string">'#button'</span>).on(<span class="string">'click'</span>, f);</span><br></pre></td></tr></table></figure>
<h3 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h3><p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象上, 然后返回一个新函数.</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">d.getTime()</span><br><span class="line"><span class="keyword">var</span> print = d.getTime;</span><br><span class="line">print() <span class="comment">//报错</span></span><br></pre></td></tr></table></figure>
<p>上述代码报错是因为<code>getTime</code>方法内部的<code>this</code>绑定了<code>Date</code>对象实例, 赋给变量<code>print</code>以后, 内部的<code>this</code>已经不在指向<code>Date</code>实例了.</p>
<p>使用<code>bind</code>方法即可解决这种问题.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = d.getTime.bind(d);</span><br><span class="line">print() <span class="comment">//正常输出</span></span><br></pre></td></tr></table></figure></p>
<p><strong><code>this</code>不仅可以绑定到原对象中,还可以绑定到其他对象中</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = &#123;</span><br><span class="line">	count: <span class="number">0</span>,</span><br><span class="line">	inc: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.count++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	count: <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> func = counter.inc.bind(obj); <span class="comment">//将inc方法中的`this	绑定到obj方法</span></span><br><span class="line">func();</span><br><span class="line">obj,count <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<h4 id="bind方法需要注意"><a href="#bind方法需要注意" class="headerlink" title="bind方法需要注意"></a><code>bind</code>方法需要注意</h4><ol>
<li>每一次返回一个新的函数</li>
<li>结合回调函数使用</li>
<li>结合call方法使用</li>
</ol>
<p>参考&gt;<a href="https://wangdoc.com/javascript/oop/this.html" target="_blank" rel="noopener">https://wangdoc.com/javascript/oop/this.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/js对象/" data-id="cjv0x3vbt000sj5rwr36lt24p" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/记忆化搜索与动态优化与背包问题" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/记忆化搜索与动态优化与背包问题/" class="article-date">
  <time datetime="2019-04-28T12:31:54.517Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##背包问题<br>动态规划（DP）—— 算法设计方法之一。</p>
<p>问题：有几个重量和价值分别为Wi和Vi的物品。从这些物品中挑选出总重量不超过W的物品，求所有挑选方案中价值总和最大的值。<br><strong>限制条件</strong><br><strong>1&lt;=n&lt;=100</strong><br><strong>1&lt;=Wi，Vi&lt;=100</strong><br><strong>1&lt;=W&lt;=10000</strong></p>
<p>输入样例：<br>n = 4<br>(w ,v) = { (2,3), (1,2),(3,4), (2,2) }<br>W=5;<br>输出样例：<br>7（选择0,1,3号）</p>
<p>这种问题就是背包问题。背包问题看起来非常复杂，需要测试很多种组合。首先我们对每个物品是否放入背包进行搜索试试看。<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_N 100</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, W; //n个 物品， 总重量不超过W</span><br><span class="line"></span><br><span class="line">int w[MAX_N], v[MAX_N];</span><br><span class="line"></span><br><span class="line">//从第i个物品开始挑选总重量小于j的部分</span><br><span class="line">int rec(int i, int j) &#123;</span><br><span class="line">    int res;</span><br><span class="line">    if (i == n) &#123;</span><br><span class="line">        //已经没有剩下的了</span><br><span class="line">        return res = 0;</span><br><span class="line">    &#125; else if (j &lt; w[i]) &#123;</span><br><span class="line">        res = rec(i + 1, j);//这个物品超重了,尝试下一个</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]); //在这里进行分支前一个是不包含第i个，后一个是包含第i个。</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    cin &gt;&gt; n ;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    cout &lt;&lt; rec(0, W) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然上述方法可以求解，但是显然这种方法不是很好。它的搜索深度为n，最坏情况需要$O(2^n)$时间复杂度。该递归调用方法使用了遍历二叉树搜索的原理。</p>
<p><img src="https://img-blog.csdn.net/20180713193515659?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="二叉树"></p>
<p>其实这里是有改进的地方，观察二叉树会发现rec(3,2)执行了两次，但是如果我们在执行第一次的时候将rec(3,2)的值保存起来，那么下次执行时就可以直接调用结果了（这便是记忆化搜索）。<br>来试试新的方法：增加一个二维数组dp[][],将执行结果没一步保存在其中。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_N 100</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int n, W; //n个 物品， 总重量不超过W</span><br><span class="line"></span><br><span class="line">int w[MAX_N], v[MAX_N];</span><br><span class="line">int dp[MAX_N][MAX_N];</span><br><span class="line"></span><br><span class="line">//从第i个物品开始挑选总重量小于j的部分</span><br><span class="line">int rec(int i, int j) &#123;</span><br><span class="line">    if (dp[i][j] != 0) &#123;</span><br><span class="line">        return dp[i][j]; //如果有记录则直接返回结果</span><br><span class="line">    &#125;</span><br><span class="line">    int res;</span><br><span class="line">    if (i == n) &#123;</span><br><span class="line">        //已经没有剩下的了</span><br><span class="line">        return res = 0;</span><br><span class="line">    &#125; else if (j &lt; w[i]) &#123;</span><br><span class="line">        res = rec(i + 1, j);//这个物品超重了,尝试下一个</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        res = max(rec(i + 1, j), rec(i + 1, j - w[i]) + v[i]); //在这里进行分支前一个是不包含第i个，后一个是包含第i个。</span><br><span class="line">    &#125;</span><br><span class="line">    dp[i][j] = res;  //结果保存</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; w[i];</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    init();</span><br><span class="line">    cout &lt;&lt; rec(0, W) &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细研究前面的算法用到的这个记忆数组。记dp[i][j]为根据rec的定义，从第i个物品开始挑选总重量小于j时，总价值最大的值。于是我们有一下递推公式。</p>
<p>$dp[n][j]=0$<br>$$dp[i][j]=\left{<br>\begin{aligned}<br> dp[i+1][j] (j&lt;w[i]) \<br>max( dp[i+1][j], dp[ii+1][j-w[i]+v[i])<br>\end{aligned}<br>\right.<br>$$<br>不用递归函数，直接使用地推公式将各项值计算出来，然后用二重信息即可解决该问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int dp[MAX_N+1][MAX_N+1] &#123;&#125;; //初始化为全0</span><br><span class="line">void solve2()&#123;</span><br><span class="line">    for(int i=0;i&lt;n-1;i--)&#123;</span><br><span class="line">        for(int j=0;j&lt;=W;j++)&#123;</span><br><span class="line">            if(j&lt;w[i])&#123;</span><br><span class="line">                dp[i][j]=dp[i+1][j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i][j]=max(dp[i+1][j] , dp[i+1][j-w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然这个函数的时间复杂度与前一个相同$O(n×W)$ ,但是简明了许多。<br>动态规划问题（dp）可以分析其递推公式。</p>
<p>注意：全局数组和静态数组会被初始化为0；局部数据需要手动初始化为0，例如：int  a[4]={} ; 或 int a[4] {} ; 或 int a[4] {0} 。如果括号里写0或什么都不写将会把数组全部初始化为0，但是如果这样写：int a[4] {1}; ，将会被初始化为1 0 0 0.</p>
<p>##其他推导方法</p>
<p>递推公式有多种推导方法，使用不同的递推公式我们可以得到多种算法。</p>
<p>####正向推导</p>
<p>刚讲到DP中关于i的循环是逆向进行的。如下递推公式是正向进行的。<br>$dp[i+1][j]:=$从前i个物品中挑选出总重量不超过j的物品时，总价值的最大值</p>
<p>$dp[0][j]=0$<br>$$dp[i+1][j]=\left{<br>\begin{aligned}<br> dp[i][j] ,(j&lt;w[i]) \<br>max( dp[i][j], dp[i][j-w[i]]+v[i])<br>\end{aligned}<br>\right.<br>$$</p>
<p>仔细观察公式会发现，dp中的i和w和v中的i不同，dp中的i表示前i个物品，而w和v中的i表示物品的编号，即编号是从0开始的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void solve() &#123;</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt;= W; j++) &#123;</span><br><span class="line">            if (j &lt; w[i]) &#123;</span><br><span class="line">                dp[i + 1][j] = dp[i][j];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                dp[i + 1][j] = max(dp[i][j], dp[i][j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###除了使用地推公式外的其他方法</p>
<p>除了用递推方式逐项求解外，还可以把状态转换想象成从“前i个物品中挑选出总重量不超过j时的状态” 向“前i+1个物品中选取总重量不超过j“ 和 ”前i+1个物品中选取总重量不超过j+w[i] 时的状态“的转移，于是可以实现如下形式。</p>
<p><img src="https://img-blog.csdn.net/20180714124844938?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<pre><code>void solve2() {
    for (int i = 0; i &lt; n; i++) {
        for (int j = 0; j &lt; W; j++) {
            dp[i + 1][j] = max(dp[i + 1][j], dp[i][j]);
            if (j + w[i] &lt;= W) {
                dp[i + 1][j + w[i]] = max(dp[i + 1][j + w[i]], dp[i][j] + v[i]);//  dp[i+1][j+w[i]]表示前i+1个物品，重量不超过j+w[i]的价值，dp[i][j]+v[i],表前i个物品重量不超过j的价值，加上第i+1个物品的价值，也就是说，它和dp[i + 1][j + w[i]]相比默认选择了第i+1个物品。
            }
        }
    }
    cout &lt;&lt; dp[n][W];


</code></pre><p>上述问题中，从当前状态转移到下一状态的形式，需要注意初项之外也需要初始化（在本问题中，因为价值的初始值为0，所以没有显示的初始化，在有些问题中初始值为无穷大等，需要显示的初始化。）<br>同一个问题可能有很多不同的解法：搜索记忆法、递推关系dp、状态转移dp等。根据具体的问题选择较好的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/记忆化搜索与动态优化与背包问题/" data-id="cjv0x3vcb001jj5rwavqja6r3" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/Fence Repair 栅栏分割" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/Fence Repair 栅栏分割/" class="article-date">
  <time datetime="2019-04-28T12:31:54.509Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##Rence Repair</p>
<p>题目：<br>农夫约翰为了修理栅栏，要将一块很长的木板分割成N块。准备切成的木板的长度为L1、L2、……、Ln. 未切割木板的长度恰好为切割木板的长度和。每次切断木板时，需要的开销为这块木板的长度。例如，长度为21的木板切割成5、8、8的三块木板。长为21的木板切割成13、8时，开销为21.再将长度为13的木板切割成长度5、8时，开销为13.于是合计开销为34。于是按题目要求将木板切割完，最小的开销是多少？</p>
<p><strong>限制条件：</strong><br><strong>1&lt;=N&lt;=2000</strong><br><strong>0&lt;=Li&lt;=5000</strong></p>
<p>输入样例：<br>N=3, L={8, 5, 8}<br>输出样例：<br>34</p>
<p>由于木板的切割顺序不确定，切割方法右很多，题目看似很难入手。然而，仔细考虑会发现我们可以用贪心算法来解决此问题。<br> 我们可以利用二叉树原理来描述切割木板。</p>
<p><img src="https://img-blog.csdn.net/20180713101142811?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>根据这个二叉树的切割方法，可以计算出总开销：<br>    3<em>2+4</em>2+1<em>3+2</em>3+5*2=33<br>根据此二叉树我们可观察到，如果想要总开销最小，最短的板应该是最深的叶子节点，而且该叶子节点一定右兄弟节点，说以该兄弟节点一定是次短板。<br>因此我们可以哈夫曼编码的方式来构造二叉树：</p>
<ul>
<li>首先将L1~Ln排序</li>
<li>取最短的两个节点合并</li>
<li>重新排序，并重步骤二</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_N 1000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N, L[MAX_N];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;L[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bool complare(int a,int b)&#123;</span><br><span class="line">	return a&gt;b;</span><br><span class="line">&#125;</span><br><span class="line">void solve()&#123;   //利用sort函数排序</span><br><span class="line">	sort(L,L+N,complare); //从大到小排序</span><br><span class="line">		for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">			cout&lt;&lt;L[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">	int ans=0;</span><br><span class="line">	while(N!=1)&#123;  //循环合并最小的两个节点</span><br><span class="line">		L[N-2]+=L[N-1];</span><br><span class="line">		N--;</span><br><span class="line">		ans+=L[N-1];</span><br><span class="line">		sort(L,L+N,complare);</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve2()&#123; //第二种方法，设法每次找到最小的两个。</span><br><span class="line">	int ans=0;</span><br><span class="line">	while(N&gt;1)&#123;</span><br><span class="line">		int mii1 =0, mii2=1;</span><br><span class="line">		if(L[mii1] &gt;L[mii2]) swap(mii1,mii2);</span><br><span class="line">		//找出最小的两个数</span><br><span class="line">		for(int i=2;i&lt;N;i++)&#123;</span><br><span class="line">			if( L[i]&lt;L[mii1])&#123;</span><br><span class="line">				mii2=mii1;</span><br><span class="line">				mii1=i;</span><br><span class="line">			&#125;else if(L[i]&lt;L[mii2])&#123;</span><br><span class="line">				mii2=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		//合并两块板</span><br><span class="line">		int t=L[mii1]+L[mii2];</span><br><span class="line">		ans+=t;</span><br><span class="line"></span><br><span class="line">		if(mii1==N-1) &#123;</span><br><span class="line">			swap(mii1,mii2);</span><br><span class="line">		&#125;</span><br><span class="line">		L[mii1]=t;</span><br><span class="line">		L[mii2]=L[N-1];</span><br><span class="line">		N--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	solve();</span><br><span class="line">//	solve2();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/Fence Repair 栅栏分割/" data-id="cjv0x3vbl000ej5rw3bk4use2" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/贪心算法-Aaruman&#39;s Army" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/贪心算法-Aaruman's Army/" class="article-date">
  <time datetime="2019-04-28T12:31:54.497Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##Saruman’s Army<br>直线上有N个点。点X的位置是Xi。从这N个点中选中若干个点，给它们添加上标记。对每一个点，其距离为R以内的区域里必须有带有标记的点（自己本身带有标记的点，可以认为与其距离为0的地方有一个带有标记的点）。在满足这个条件的情况下，希望能够为尽可能少的点添加标记？<br><strong>限制条件:</strong><br><strong>1&lt;=N&lt;=1000</strong><br><strong>0&lt;=R&lt;=1000</strong><br><strong>0&lt;=Xi&lt;=1000</strong></p>
<p>输入示例：<br>N=6<br>R=10<br>X={1，7，15，20，30，50}</p>
<p>输出示例：<br>3</p>
<p>思路：<br>第一步，我们可以从最左边一个点开始考虑，最左边的点的右边距离为R的区域里必须有一个被标记的点，那么我们选取哪个点呢？为了尽可能少的标记点，显然，我们选区在R内最靠右的点。</p>
<p><img src="https://img-blog.csdn.net/20180713084333253?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>第二步，以刚才标记的点为起点，向右标记标记距离R以外的第一个点。</p>
<p><img src="https://img-blog.csdn.net/20180713084348602?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>第三步，不断重复第二步过程……</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">//Saruman&apos;s Army</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#define MAX_N 1000</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int N ,R ; //N表示点个数，R距离</span><br><span class="line">int X[MAX_N];//X保存每个点的位置</span><br><span class="line">bool point[MAX_N];</span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;N&gt;&gt;R;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;X[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">void solve()&#123;</span><br><span class="line">	int temp;</span><br><span class="line">	for(int i=1;i&lt;N;i++)&#123; //步骤一，找到第一个标记的点</span><br><span class="line">		if( (X[i]-X[0]) &gt;=R)&#123;</span><br><span class="line">			point[i-1]=false;</span><br><span class="line">			temp=i;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(temp&lt;N)&#123;   //循环操作步骤二</span><br><span class="line">		int i=temp;</span><br><span class="line">		i++;</span><br><span class="line">		if( (X[i]-X[temp]) &lt;X[i] )&#123;</span><br><span class="line">			temp=i;</span><br><span class="line">			point[i]=true;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	int count=0;   //统计标记点的个数</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		if(point[i]) count++; </span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;count&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	solve();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/贪心算法-Aaruman's Army/" data-id="cjv0x3vcd001lj5rw3jgzyp1f" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/贪心算法分析" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/贪心算法分析/" class="article-date">
  <time datetime="2019-04-28T12:31:54.493Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##1、硬币问题</p>
<p>题目：<br>有1元、5元、10元、100元、500元的硬币各C1、C5、C10、C50、C100、C500枚。现在要用这些硬币来值付A元，最少需要多少枚硬币？假设本题至少存在一种值付方案。</p>
<p>限制条件：<br><strong>0&lt;=C1,C5,C10,C50,C100,C500&lt;=10^9</strong><br><strong>0&lt;=A&lt;=10^9</strong></p>
<p>输入样例：<br><strong>C1=3，C5=2,C10=1,C50=3,C100=0,C500=2,A=620</strong><br>输出样例：<br><strong>6（500元1枚，50元2枚，10元1枚，5元2枚，合计6枚）</strong></p>
<p>该问题中，我们优先使用面值较大的硬币。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const static int v[6] = &#123; 1,5,10,50,100,500 &#125;;</span><br><span class="line"></span><br><span class="line">int C[6];</span><br><span class="line">int count[6];</span><br><span class="line">int A;</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	for(int i=0;i&lt;6;i++)&#123;</span><br><span class="line">		cin&gt;&gt;C[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sove()&#123;</span><br><span class="line">	int ans=0;</span><br><span class="line">	for(int i=5;i&gt;=0;i--)&#123;</span><br><span class="line">		int temp=min(A/v[i], C[i]); //第i种硬币最多可以使用A/v[i]个，C[i],表示第i种硬币的个数，说以取两者较小值</span><br><span class="line">		A-=temp*v[i];</span><br><span class="line">		count[i]=temp;</span><br><span class="line">		ans+=temp;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;&quot;(&quot;;</span><br><span class="line">	for(int i=5;i&gt;=0;i--)&#123;</span><br><span class="line">		cout&lt;&lt;v[i]&lt;&lt;&quot;元&quot;&lt;&lt;count[i]&lt;&lt;&quot;枚,&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;&quot;)&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	sove();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##1、区间问题<br>问题：区间调度问题<br>现在又n项工作，每项工作分别在Si时间开始，在ti时间结束。对于每项工作，你都可以选择参与与否。如果选择了参与，那么自始至终都必须全程参与。此外，参与工作的时间段不能重叠（即使是开始的瞬间和结束的瞬间也是不允许的）。<br>限制条件：<br><strong>1&lt;=N&lt;=100000</strong><br><strong>1&lt;=si&lt;=ti&lt;=10^9</strong></p>
<p>输入样例：<br><strong>n=5, s={1,2,4,6,8}, t={3,5,7,8,10}</strong><br>输出样例：<br><strong>3（选取工作1、3、5）</strong></p>
<p>算法分析：在可选工作中吗，每次都选择结束时间最早的工作。</p>
<p>设计代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">#define MAX_N 100000</span><br><span class="line"></span><br><span class="line">//用于对工作排序</span><br><span class="line">pair&lt;int, int&gt; itv[MAX_N];</span><br><span class="line">int N, S[MAX_N], T[MAX_N];</span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;N;</span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;S[i];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;N;i++)&#123;</span><br><span class="line">		cin&gt;&gt;T[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void sove()&#123;</span><br><span class="line">	//对pair排序，T放入first，S放入second</span><br><span class="line">	for(int i=0; i&lt;N; i++)&#123;</span><br><span class="line">		itv[i].first=T[i];</span><br><span class="line">		itv[i].second=S[i];</span><br><span class="line">	&#125;</span><br><span class="line">	sort(itv, itv+N); //按t(工作结束时间)排序</span><br><span class="line">	int ans=0,t=0;</span><br><span class="line">	for(int i=0; i&lt;N ; i++)&#123;</span><br><span class="line">		if(t&lt;itv[i].second)&#123;</span><br><span class="line">			ans++;</span><br><span class="line">			t=itv[i].first;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	sove();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##3、字典最小问题</p>
<p>题目：Best Cow Line(POJ 3617)<br>给定长度为N的字符串S,要构造一个长度为N的字符串T。T是一个空串，随后反复进行下列任意操作。<br>从S头部删除一个字符，加到T的尾部<br>从S尾部删除一个字符，加到T的尾部<br>目标是要构造字典序尽可能小的字符串T。<br>限制条件：<br><strong>1&lt;=N&lt;=2000</strong><br><strong>字符串S只包含大写英文字母</strong></p>
<p>输入示例：<br>N=6;<br>S=”ACDBCB”<br>输出示例：<br>ABCBCD</p>
<p>操作过程示意图：<br><img src="https://img-blog.csdn.net/20180712195153331?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="操作过程"></p>
<p>分析：</p>
<ul>
<li>不断取S的开头和末尾中较小的一个字符放入到T的末尾<ul>
<li>但是这样做会出现一个问题，如果S开头和末尾相同，接下来一个也相同，再接下一个也相同，……. 。这样的化难道需要我们依次进行判断怕然比较大小吗？其实不需要这样做，我们可以利用字符串比大小的原理来设计算法。</li>
</ul>
</li>
<li>比较字符串S和S‘ 的大小</li>
<li>将较小的字符串的首字母移入T</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n;</span><br><span class="line">string S;</span><br><span class="line">string T=&quot;&quot;;</span><br><span class="line">string SR;</span><br><span class="line"></span><br><span class="line">void sove()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	cin&gt;&gt;S;</span><br><span class="line">	int leng=S.length();</span><br><span class="line">	SR=S.substr(0, leng/2);</span><br><span class="line">	reverse(S.begin(),S.end());</span><br><span class="line">	if(leng%2!=0)</span><br><span class="line">		S=S.substr(0,leng/2+1);</span><br><span class="line">	else S=S.substr(0,leng/2);</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	for(int i=0;i&lt;leng;i++)&#123;</span><br><span class="line">		if(SR.length()==0)&#123;</span><br><span class="line">			T.append(S);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(S.length()==0)&#123;</span><br><span class="line">			T.append(SR);</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">		if(SR&lt;S)&#123;</span><br><span class="line">			T.append(SR.substr(0,1));</span><br><span class="line">			SR=SR.substr(1);</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			T.append(S.substr(0,1));</span><br><span class="line">			S=S.substr(1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	sove();</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/贪心算法分析/" data-id="cjv0x3vcd001mj5rwqlo3jx0i" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/最基础的穷竭搜索（2）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/最基础的穷竭搜索（2）/" class="article-date">
  <time datetime="2019-04-28T12:31:54.485Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##特殊状态的枚举<br>虽然生成可行空间多数采用深度优先搜索，但在装态空间比较特殊时其实可以简短的实现。比如，c++标准库中提供了next_permutation函数，它可以把n个元素共n!中不同的排列组合生成出来。又或者，通过使用位运算符，可以枚举出从n个元素中取出k个的所有情况，或某个集合的所有子集。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;algorithm&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_N 1000</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">bool used[MAX_N];</span><br><span class="line">int perm[MAX_N];</span><br><span class="line"></span><br><span class="line">//生成&#123;0，1，2，3，4，……，n-1&#125;种排序</span><br><span class="line">void permutation1(int pos,int n)&#123;</span><br><span class="line">	if(pos == n)&#123;</span><br><span class="line">		//在这里编写处理perm的程序</span><br><span class="line">		for(int i=0;i&lt;n;i++) cout&lt;&lt;perm[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	//perm的第pos个位置，究竟使用哪一个元素循环</span><br><span class="line">	for(int i=0 ;i&lt;n;i++)&#123;</span><br><span class="line">		if(!used[i])&#123;</span><br><span class="line">			perm[pos]=i;</span><br><span class="line">			used[i]=true;</span><br><span class="line">			permutation1(pos+1,n);</span><br><span class="line">			used[i]=false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int perm2[MAX_N];</span><br><span class="line">void permutation2(int n)&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		perm2[i]=i;</span><br><span class="line">	&#125;</span><br><span class="line">	do&#123;</span><br><span class="line">		//此处编写对perm2的操作</span><br><span class="line">		for(int i=0;i&lt;n;i++) cout&lt;&lt;perm2[i]&lt;&lt;&quot; &quot;;</span><br><span class="line">		cout&lt;&lt;endl;</span><br><span class="line">	&#125;while(next_permutation(perm2,perm2+n));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">	permutation1(0,5 );</span><br><span class="line">	permutation2(5);</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于1~n-1的全排列，上述代码提供可两种方法：<br>permutation1方法使用了深度优先搜索算法，该算法为perm数组的每个位置从剩余的元素中挑选一个。<br>permutation2方法调用了C++ STL提供的<algorithm>头文件下提供的next_permutation方法。</algorithm></p>
<p>##剪枝</p>
<p>当我们使用穷竭搜索时，程序会把所有可能的情况都列出来，如果有n个数，那么算法是时间复杂度为O(n!)。这样一来，当n较大时，计算会消耗大量时间。<br>当我们进行深度优先搜索时，到某个状态时已经明确知道在往下搜索不会有解，这时可以跳过，这种行为就称为剪枝。</p>
<p>之前有一个求部分和问题。</p>
<p>例题：部分和问题：<br>给定整数 a­1 、a2 、…… 、an，判断是否可以从中选出若干数，使它们的和恰好为K。<br> 限制条件：1 ≤ n ≤ 20 ；-108≤ ai ≤ 108；-108≤ k≤108；<br>输入样例：n=4 </p>
<pre><code>a={1，2，4，7}
  k=13
</code></pre><p>输出样例：Yes(13 = 2+4+7)</p>
<p>//给出整数a1~an,判断是否可以从中找出若干，使它们的和为k</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line">int n,k, * a;  //n为输入数据个数，k为所要的求和，a*为输入的数据数组</span><br><span class="line">void init()&#123;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	a=new int[n];</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		cin&gt;&gt;a[i];</span><br><span class="line">	&#125;</span><br><span class="line">	cin&gt;&gt;k;</span><br><span class="line">&#125;</span><br><span class="line">bool dfs(int i,int sum)&#123;</span><br><span class="line">	if(i==n) return sum=k;</span><br><span class="line">	if(dfs(i+1,sum) ) return true;</span><br><span class="line">	if(dfs(i+1,sum+a[i]))return true;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	init();</span><br><span class="line">	if(dfs(0,0)) cout&lt;&lt;&quot;Yes&quot;;</span><br><span class="line">	else cout&lt;&lt;&quot;No&quot;;</span><br><span class="line">	return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法其实很简单，如上，dfs只用了五行代码。</p>
<p>假如我们输入的数组长度为5，它们分别为1、2、3、4、5，求它们任意和的总情况有多少种呢？</p>
<p>我们可以这样分析，可以把他作为概率论的问题，从中任意挑几个数，1出现或不出现有两种情况，2出现或不出现有两种情况，……。说以总情况为2^5种。</p>
<p>说以，我们可以以此来画一个二叉树，每层节点代表一个数，左边为不出现，右边为出现：</p>
<p><img src="https://img-blog.csdn.net/20180712172524425?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<blockquote>
<p>求部分和<a href="https://blog.csdn.net/qq_28120673/article/details/80781806" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/80781806</a></p>
</blockquote>
<p>上述算法中dfs算法代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int i,int sum)&#123;</span><br><span class="line">	if(i==n) return sum=k;</span><br><span class="line">	if(dfs(i+1,sum) ) return true;</span><br><span class="line">	if(dfs(i+1,sum+a[i]))return true;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改进该算法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool dfs(int i,int sum)&#123;</span><br><span class="line">	if(i==n) return sum=k;</span><br><span class="line">	if(sum&gt;k) return false;//如果sum&gt;k时在往下加一定不会等于k</span><br><span class="line">	if(dfs(i+1,sum) ) return true;</span><br><span class="line">	if(dfs(i+1,sum+a[i]))return true;</span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/最基础的穷竭搜索（2）/" data-id="cjv0x3vc7001dj5rwyj2d6cx6" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/深度优先搜索解决Lake Counting （POJ No.2386)" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/深度优先搜索解决Lake Counting （POJ No.2386)/" class="article-date">
  <time datetime="2019-04-28T12:31:54.477Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##深度优先搜索解决 Lake Counting （POJ No.2386)</p>
<p>问题：<br>有一个大小为N<em>M的园子，雨后集起了水。八联通的积水被认为是连在一起的。请求出园子里中共有多少水洼？（八联通是指下图中相对W的</em>的部分)    </p>
<pre><code>*   *   *
*   w  *
*   *   *
</code></pre><p> 限制条件: N,M&lt;=100;<br> 输入示例：<br> N=10，M=12；<br> 园子如下图（‘W’表示积水，’.‘表示没有积水）<br><strong>W  .   .    .    .    .    .    .    .  W W  .</strong><br><strong>.   W W W   .    .    .    .    .  W W W</strong><br><strong>.    .    .   .  W  W   .    .    .  W W   .</strong><br><strong>.     .    .   .   .    .     .    .    . W W    .</strong><br><strong>.    .    .   .   .    .     .    .    . W  .     .</strong><br><strong>.    .   W  .  .    .     .    .    .  W  .    .</strong><br><strong>.   W   .  W .   .     .    .    .  W  W  .</strong><br><strong>W .   W  .  W .     .    .    .   .   W   . </strong><br><strong>.  W   .   W .  .     .    .    .   .    W  . </strong><br><strong>.   .   W   .  .  .     .     .    .   .   W  .</strong></p>
<p>输出示例：3</p>
<p>算法思想：从任意的W开始扫描，不停的把相邻的W替换成“ . ” ，采用DFS算法，一次扫描过后，可以把与这个W相连的W区替换成“ .” 。多次扫描，直到W不再减少时，计算W 个数，即是水洼个数。<br>代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_N 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_M 100</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">char</span> garden[MAX_N][MAX_M];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">cin</span>&gt;&gt;N&gt;&gt;M;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">			<span class="built_in">cin</span>&gt;&gt;garden[i][j];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i ,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=N || j&lt;<span class="number">0</span> || j&gt;=M)</span><br><span class="line">		<span class="keyword">return</span> ;</span><br><span class="line">	<span class="keyword">if</span>( garden[i+<span class="number">1</span>][j] == <span class="string">'W'</span>) &#123;  garden[i+<span class="number">1</span>][j]=<span class="string">'.'</span>; dfs(i+<span class="number">1</span>,j);  &#125; <span class="comment">//下</span></span><br><span class="line">	<span class="keyword">if</span>(garden[i][j+<span class="number">1</span>] == <span class="string">'W'</span>) &#123; garden[i][j+<span class="number">1</span>] = <span class="string">'.'</span> ; dfs(i, j + <span class="number">1</span> ); &#125; <span class="comment">//右</span></span><br><span class="line">	<span class="keyword">if</span>(garden[i+<span class="number">1</span>][j+<span class="number">1</span>] == <span class="string">'W'</span>) &#123; garden[i+<span class="number">1</span>][j+<span class="number">1</span>] = <span class="string">'.'</span> ; dfs(i +<span class="number">1</span>, j+<span class="number">1</span> ); &#125; <span class="comment">//右下</span></span><br><span class="line">	<span class="keyword">if</span>(garden[i+<span class="number">1</span>][j<span class="number">-1</span>] == <span class="string">'W'</span>) &#123; garden[i+<span class="number">1</span>][j<span class="number">-1</span>] = <span class="string">'.'</span> ; dfs(i +<span class="number">1</span>, j<span class="number">-1</span> ); &#125;<span class="comment">//左下</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>( garden[i<span class="number">-1</span>][j] == <span class="string">'W'</span>) &#123;  garden[i<span class="number">-1</span>][j]=<span class="string">'.'</span>; dfs(i<span class="number">-1</span>,j);  &#125; <span class="comment">//上</span></span><br><span class="line">	<span class="keyword">if</span>( garden[i][j<span class="number">-1</span>] == <span class="string">'W'</span>) &#123;  garden[i][j<span class="number">-1</span>]=<span class="string">'.'</span>; dfs(i,j<span class="number">-1</span>);  &#125; <span class="comment">//左</span></span><br><span class="line">	<span class="keyword">if</span>( garden[i<span class="number">-1</span>][j<span class="number">-1</span>] == <span class="string">'W'</span>) &#123;  garden[i<span class="number">-1</span>][j<span class="number">-1</span>]=<span class="string">'.'</span>; dfs(i<span class="number">-1</span>,j<span class="number">-1</span>);  &#125; <span class="comment">//左上</span></span><br><span class="line">	<span class="keyword">if</span>( garden[i<span class="number">-1</span>][j+<span class="number">1</span>] == <span class="string">'W'</span>) &#123;  garden[i<span class="number">-1</span>][j+<span class="number">1</span>]=<span class="string">'.'</span>; dfs(i<span class="number">-1</span>,j+<span class="number">1</span>);  &#125; <span class="comment">//右上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;M;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(garden[i][j]==<span class="string">'W'</span>)&#123;</span><br><span class="line">				dfs( i , j);</span><br><span class="line">				count++;</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;count&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/深度优先搜索解决Lake Counting （POJ No.2386)/" data-id="cjv0x3vca001hj5rwhayapqtg" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/使用递推关系的动态规划dp解决问题（最长公共子序列和完全背包问题）" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/使用递推关系的动态规划dp解决问题（最长公共子序列和完全背包问题）/" class="article-date">
  <time datetime="2019-04-28T12:31:54.469Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##最长公共子序列问题<br>问题：<br>给定两个字符串$ S_1S_2……S_1 $和$t_1t_2……t_n$ 。求出这两个字符串最长公共秩序了的长度。字符串$S_1S_2……S_n$ 的秩序了可以表示为<br>$S_{i1} S_{i2}……S_{im}(i1&lt;i2&lt;……im)$的序列。</p>
<p>限制条件<br>$1 \leqslant n \leqslant 1000$</p>
<p>输入样例：<br>n=4<br>m=4         //n、m分别为两个字符串的长度<br>s=”abcd”<br>t=”becd”</p>
<p>输出样例<br>3（”bcd“）</p>
<p>这个问题是经典的最长公共子序列问题。虽然算法不难实现，但是我们今天将尝试使用动态规划来解决此问题。<br>dp[i][j] :=s1……si 和 t1……tj对应的LCS的长度，<br>由此，$s_1……s_{i+i}$ 和 $ t_1……t_{j+1}对应的公共子列可能是下列三者中的一个：</p>
<ul>
<li>当$s_{i+1}=t_{j+1} $时，在$s_1……s_i$和$t_1……t_j$的公共子列末尾加-上$s_{i+1}$ </li>
<li>$s_1……s_i$和$t_1……t_{j+1}$的公共子列</li>
<li><p>$s_1……s_{i+1}$和$t_1……t_j$的公共子列</p>
<p>所以有以下递推关系成立：</p>
</li>
</ul>
<p>$$dp[i+1][j+1]=\left{<br>\begin{aligned}<br> max(dp[i][j]+1, dp[i][j+1],dp[i+1][j]),(s_{i+1}=t_{j+1})\<br>max( dp[i][j+1], dp[ii+1][j]),(其他)<br>\end{aligned}<br>\right.<br>$$</p>
<p>分析可发现：$ dp[i+1][j+1]=max(dp[i][j]+1, dp[i][j+1],dp[i+1][j])$其实可以直接换成：<br>$ dp[i+1][j+1]=dp[i][j]+1$</p>
<p>公式的时间复杂度为$O(nm)$公式中dp[n][m]表示的就是LCS的长度。</p>
<table>
<thead>
<tr>
<th style="text-align:center">j\i</th>
<th style="text-align:right">0</th>
<th style="text-align:right">1(b)</th>
<th style="text-align:left">2(e)</th>
<th>3(c)</th>
<th>4(d)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>0</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:left">0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>1(a)</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">0</td>
<td style="text-align:left">0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td style="text-align:center"><strong>2(b)</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:left">1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td style="text-align:center"><strong>3(c)</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:left">1</td>
<td>2</td>
<td>2</td>
</tr>
<tr>
<td style="text-align:center"><strong>4(d)</strong></td>
<td style="text-align:right">0</td>
<td style="text-align:right">1</td>
<td style="text-align:left">1</td>
<td>2</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define MAX_N 10000</span><br><span class="line">#define  MAX_M 10000</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int n ,m;</span><br><span class="line">char s[MAX_N] , t[MAX_M];</span><br><span class="line">int dp[MAX_N+1][MAX_M+1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    for(int i=0;i&lt;n;i++)</span><br><span class="line">    cin&gt;&gt;s[i];</span><br><span class="line"></span><br><span class="line">    for(int i=0;i&lt;m;i++)</span><br><span class="line">        cin&gt;&gt;t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">    for(int i=0 ;i&lt;n ; i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;m;j++)&#123;</span><br><span class="line">            if(s[i]==t[j])&#123;</span><br><span class="line">                dp[i+1][j+1]=dp[i][j]+1;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i+1][j+1]=max(dp[i][j+1], dp[i+1][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>##进一步探讨递推关系<br>问题：完全背包问题<br>有n种重量和价值分别为$w_i,v_i$的物品。从这些物品中挑选总重量不超过w的物品，求出挑选物品的总价值的最大值。在这里，每种物品可以任意选多件。<br><strong>限制条件</strong></p>
<ul>
<li>$1\leqslant n \leqslant 100$</li>
<li>$1 \leqslant w_i,v_i \leqslant 100$</li>
<li>$1 \leqslant W \leqslant 1000$</li>
</ul>
<p>输入样例：<br>n=3<br>(w,v)={(3,4), (4,5), (2,3)}<br>w=7<br>输出样例：<br>10（0号物品选1个，2号物品选两个）</p>
<p>这了例题中，和之前的不同之处在于每种物品可以选任意多个。</p>
<blockquote>
<p>[上一个背包问题]<a href="https://blog.csdn.net/qq_28120673/article/details/81037700" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/81037700</a></p>
</blockquote>
<p>首先尝试写出递推关系式<br>设dp[i+1][j] 表示从前i种物品中总重量不超过j的最大总价值。那么递推关系为：<br>$dp[0][j]=0$<br>$dp[i+1][j]=max{dp[i][j-k \times w[i]]+ k \times v[i] | 0\leqslant k}$</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#define MAX_N 100</span><br><span class="line">#define  MAX_M 100</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int  n,W;</span><br><span class="line">int w[MAX_N],v[MAX_N];</span><br><span class="line">int dp[MAX_N+1][MAX_M+1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void init()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;W;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void solve()&#123;</span><br><span class="line">  for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">      for(int j=0;j&lt;=W;j++)&#123;</span><br><span class="line">          for(int k=0;k*w[i] &lt;= j; k++)&#123;</span><br><span class="line">              dp[i+1][j]=max( dp[i+1][j],dp[i][j-k*w[i]]+k*v[i] );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;dp[n][W];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    init();</span><br><span class="line">    solve();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该算法的核心为三重循环</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">      for(int j=0;j&lt;=W;j++)&#123;</span><br><span class="line">          for(int k=0;k*w[i] &lt;= j; k++)&#123;</span><br><span class="line">              dp[i+1][j]=max( dp[i+1][j],dp[i][j-k*w[i]]+k*v[i] );</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，dp[i][j],表示的是选取i个物品种类，当i等于0时表示没有选物品，此时dp[0][j]=0,这个值的设定是在数组初始化就设置的，其目的为递推提供初始值。j表示物品的总重量，很显然物品的重量不能是负数，所以j-k<em>w[i]&gt;=0, 即第三个循环中k</em>w[i]&lt;=j;<br>显而易见的是前两个循序是遍历所有物品种类和数量的组合（这里并不是排列，可以想成将物品按编号从1～n排列。i表示只从编号1～i中抽取物品，编号在这范围内可以抽也可以不抽，），然后第三个循环不容易理解（花了我半天的时间才看懂，泪奔～～～）。<br>$dp[i+1][j] = max( dp[i+1][j] , dp[i][j -k<em>w[i]] +k </em>v[i] );$<br>分析：<br>首先回顾一下示例数据：<br>n= 3<br>( w, v ) = { (3,4), (4,5), (2,3) }<br>w = 7</p>
<p>假如dp[i][0~n]的最大值已经求出当，当我们要求dp[i+1][…]的时候（实际上当求dp[i+1][..]的时候，dp[i][…]已近求出）可以认为是在挑选k件i号物品后，然后在前i件物品中挑选，显然dp[i][..]最大值我们已近知道，所以选出k*v[i]+dp[i][…]的最大值就是dp[i+1][…]的最大值。</p>
<p>下面分析递推过程：</p>
<ol>
<li>dp[1][0]<br> 当j=0；每个物品的重都大于0，所以，k=0时，dp[1][0]=dp[0][0]=0;<br> 同理，可得，dp[1][1]=dp[1][2]=0;</li>
<li>dp[1][3]<br> 当k=0，dp[1][3]=dp[0][3]=0;<br> 当k=1，dp[1][3]=dp[0][1<em>3]+1</em>4=4;<br> 当k=2… ,k*w[i]&gt;3</li>
<li>dp[2][0]<br> 显然j=0,1,2时dp[i][j]=0;</li>
<li>dp[2][3]<br> 当k=0，dp[2][3]=0;<br> 当k=1，dp[2][3]=dp[1][3-1<em>3]+1</em>3=3;<br> 当k为其他值时，k*w[1]&gt;j;<br> 同理我们可以求出dp[2][4]=dp[2][5]=5, dp[2][6]=8, dp[2][7]=9。</li>
<li>dp[3][0]<br> 因为w[2]=2，所以，dp[3][0]=dp[3][1]=0; </li>
<li>dp[3][2]<br> 当k=1，k<em>w[2]=2&lt;=j , 所以dp[3][2]=dp[2][2- 1</em>2]+v[2]=3;<br> 当k=其他值时，均超出范围。</li>
<li><p>dp[3][3]<br> 当k=0,dp[3][3]=dp[2][3]=4;<br> 当k=1, dp[3][3]=dp[2][1]+v[2]=3;<br> 当k=其他值将超出范围；<br> 所以dp[3][3]最大值为3.<br>8.dp[3][4]<br> 当k=0, dp[3][4]=dp[2][4]=5;<br> 当k=1，dp[3][4]=dp[2][4-1<em>2]+v[2]=dp[2][2]+3=3;<br> 当k=2，dp[3][4]=dp[2][4-2</em>2]+2<em>v[2]=dp[2][0]+2</em>v[2]=6;<br> 当k=其他值，将超出范围控制。</p>
<p>同理可以得出dp[3][5]=7,dp[3][6]=7,dp[3][7]=10。</p>
</li>
</ol>
<p>###算法到这里就完了？<br>并不是这样，其实我们还可以进一步优化它。<br>上面的算法中我们使用了三重循环。k的循环最大为W，所以最大时间复杂度为$O(nW^2)$ 。该算法中其实有一些多余的计算，接下来我们将多余的计算去除。<br>在dp[i+1][j]的计算中选择k(k&gt;=1)个的情况，与dp[i+1][j-w[i]]中选择k-1的情况是相同的，所以dp[i+1][j]的递推式中k&gt;=1的部分在计算中已经在dp[i+1][j-w[i]]的计算中完成了。为啥会这样呢，这个问题要从dp[][]的意义分析，dp[i+1][j-w[i]]表示在前i+1个物品中选择，即0～i号物品中选择。j-w[i]表示已选择一个i号物品，所以当k&gt;=1时，一定至少选择了一个i号物品。说以dp[i+1][j-w[i]] ，包含了dp[i+1][j-k*w[i]],(k&gt;=1)的情况。</p>
<p>改进后代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void solve2()&#123;</span><br><span class="line">    for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">        for(int j=0;j&lt;=W;j++)&#123;</span><br><span class="line">            if(j&lt;w[i])&#123;</span><br><span class="line">                dp[i+1][j]=dp[i][j];</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                dp[i+1][j]=max(dp[i][j], dp[i+1][j-w[i]] +v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;&quot; \n&quot;&lt;&lt;dp[n][W] &lt;&lt;&quot;\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/使用递推关系的动态规划dp解决问题（最长公共子序列和完全背包问题）/" data-id="cjv0x3vc40018j5rwie4yw0v7" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/动态优化的再次优化，将dp数组从二维改为一维" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/动态优化的再次优化，将dp数组从二维改为一维/" class="article-date">
  <time datetime="2019-04-28T12:31:54.465Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>此文上接:</p>
<blockquote>
<p>1、记忆化搜索与动态优化与背包问题<br><a href="https://blog.csdn.net/qq_28120673/article/details/81037700" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/81037700</a><br>2、使用递推关系的动态规划dp解决问题（最长公共子序列和完全背包问题）<br><a href="https://blog.csdn.net/qq_28120673/article/details/81043671" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/81043671</a></p>
</blockquote>
<p>通过上面的讨论，已近解决了动态规划的使用问题。上面的背包问题中，我们使用了二维数组来存储规划过程，基本上可以说动态规划是利用空间换取时间的方法。在计算中可以发现其实数组是可以重复使用的，我们可以只是用一行数组记录动态规划过程。</p>
<p>在01背包问题中，将dp[MAX_N+1][MAX_N+1]改为dp[MAX_N+1]。在i的每次循序将第二行数据覆盖第一行。<br>其算法如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int dp[MAX_W+1];</span><br><span class="line">void solve()&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=W;j&gt;=w[i];j--)&#123;</span><br><span class="line">			dp[j]=max( dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[w]&lt;&lt;endl;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完全背包问题中有类似的方法：<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int dp[MAX_W+1];</span><br><span class="line">void solve()&#123;</span><br><span class="line">	for(int i=0;i&lt;n;i++)&#123;</span><br><span class="line">		for(int j=w[i];j&lt;=W;j++)&#123;</span><br><span class="line">			dp[j]=max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;dp[W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细观察方向，这两个算法的差别在于循环方向不同。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/动态优化的再次优化，将dp数组从二维改为一维/" data-id="cjv0x3vc6001aj5rw007dyxq7" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/优先队列和堆" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/优先队列和堆/" class="article-date">
  <time datetime="2019-04-28T12:31:54.457Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <p>##优先队列和堆</p>
<p>###1、优先队列<br>能够完成一下操作的队列叫优先队列：</p>
<ol>
<li>插入一个数值</li>
<li><p>取出最小的数值（获得值并删除）</p>
<p>能够使用二叉高效解决上述问题的，是一种叫做堆(实际上堆有不同的数据结构，这里叫做二叉堆的数据结构)的数据结构。</p>
</li>
</ol>
<p>###2、堆的结构<br>堆的结构为二叉树：<br>堆的主要二叉树特性为：<br>    1、所有的儿子节点的值一定不小于父亲节点值。<br>    2、树的节点是重上到下，从左往右的顺序紧凑排列的。</p>
<p>向堆中插入数值，其首先将插入值放在二叉树末尾，然后根据其值的大小往上移动。<br><img src="https://img-blog.csdn.net/20180716144332755?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="插入前"></p>
<p> <img src="https://img-blog.csdn.net/20180716144404644?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="插入新节点"></p>
<p><img src="https://img-blog.csdn.net/20180716144424401?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="节点上移"></p>
<p><img src="https://img-blog.csdn.net/20180716144451677?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="继续上移"></p>
<p><img src="https://img-blog.csdn.net/20180716144515194?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="到达合适位置"></p>
<p>上面的一组图片展示了如何插入数据。很明显的是每次插入并调整堆后，堆的顶端保持为最小值的节点。<br>当我们取出最小根后，再次调整堆。</p>
<p>###堆的复杂度<br>堆的加入和取出操作花费时间都和堆的深度成正比。如果有n个元素，那么每个操作可以$O(logn)$的时间内完成。</p>
<p>###堆的实现<br>我们采用数组来存储二叉树。儿子节点满足一下性质：</p>
<ol>
<li>左儿子的编号为自己编号×2+1；</li>
<li>右儿子的编号为自己编号×2+2；</li>
</ol>
<p><img src="https://img-blog.csdn.net/20180716150745630?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数组存储二叉树"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">#define MAX_N 1000</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class ArrayHeap &#123;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    int heap[MAX_N], sz = 0;</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    void push(int x) &#123;</span><br><span class="line">        int i = sz++; //i表示加入的节点的编号</span><br><span class="line">        while (i &gt; 0) &#123;</span><br><span class="line">            int p = (i - 1) / 2;</span><br><span class="line">            if (heap[p] &lt;= x) break;  //不用调整</span><br><span class="line"></span><br><span class="line">            heap[i] = heap[p];</span><br><span class="line">            i = p;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int pop() &#123; //pop操作时，将最后一层的最右边一个节点x取出，重新调整各节点将x安放在合适的位置</span><br><span class="line">        int ret = heap[0];</span><br><span class="line">        int x = heap[--sz]; //sz表示个数，而数组是从0号开始，所以--sz</span><br><span class="line">        //从根开始向下交换</span><br><span class="line">        int i = 0;</span><br><span class="line">        while (i * 2 + 1 &lt; sz) &#123;  //此条件表白i号结点的左右孩子都存在，左孩子小于sz表明右孩子小于或等于sz</span><br><span class="line">            int lc = i * 2 + 1, rc = i * 2 + 2; //lc,rc分别为左右孩子的标号。</span><br><span class="line">            if (rc &lt; sz &amp;&amp; heap[rc] &lt; heap[lc]) lc = rc;  //将较小的孩子节点编号给lc</span><br><span class="line"></span><br><span class="line">            if (heap[lc] &gt;= x) break; //如果已经没有大小颠倒</span><br><span class="line"></span><br><span class="line">            heap[i] = heap[lc]; //将较小的提上来</span><br><span class="line">            i = lc;</span><br><span class="line">        &#125;</span><br><span class="line">        heap[i] = x;</span><br><span class="line"></span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>实际使用中我们大可不必自己编写堆的实现，在c++标准模板库STL中已经为我们准备了priority_queue类，该类为大根堆，即每次取出的都是最大值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;int&gt; pque;</span><br><span class="line"></span><br><span class="line">    srand((unsigned)time(NULL));</span><br><span class="line">   for(int i=0;i&lt;100;i++)&#123;</span><br><span class="line">       pque.push(rand()%100);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  while(!pque.empty())&#123;</span><br><span class="line">      cout&lt;&lt;pque.top()&lt;&lt;&quot;\t&quot;;</span><br><span class="line">      pque.pop();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/优先队列和堆/" data-id="cjv0x3vc30016j5rwa9sg2p47" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    
  <div class="widget-wrap">
     
        <h3 class="follow-title ">Follow me</h3>
     
    <div class="widget follow">
      
              <a class="github" aria-hidden="true" href="https://github.com/wycnet" target="_blank" title="Github"></a>
      
      
            <a class="weibo" aria-hidden="true" href="http://weibo.com/wyc" target="_blank" title="微博"></a>
      
      
              <a class="zhihu" aria-hidden="true" href="http://www.zhihu.com/" target="_blank" title="知乎"></a>
      
      
            <a class="email" aria-hidden="true" href="mailto:1982659010@qq.com" target="_blank" title="邮箱"></a>
      
    </div>
  </div>


  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title categories">分类</h3>
    <div class="widget" id="categories">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo入坑/">hexo入坑</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/hexo入坑/阿里云服务器搭建hexoblog/">阿里云服务器搭建hexoblog</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/tensorflow/">tensorflow</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/测试/">测试</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/测试/12/">12</a><span class="category-list-count">1</span></li></ul></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title tagcloud">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/hexo/" style="font-size: 14px; color: #00f">hexo</a> <a href="/tags/te/" style="font-size: 14px; color: #00f">te</a> <a href="/tags/tensorflow/" style="font-size: 14px; color: #00f">tensorflow</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/28/csdn转移/js对象/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/记忆化搜索与动态优化与背包问题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/Fence Repair 栅栏分割/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/贪心算法-Aaruman's Army/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/贪心算法分析/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title archive">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">四月 2019</a><span class="archive-list-count">42</span></li></ul>
    </div>
  </div>


  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 wycan&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;1982659010@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>