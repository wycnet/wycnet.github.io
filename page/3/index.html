<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>wycBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="wycBlog">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="wycBlog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wycBlog">
  
    <link rel="alternate" href="/atom.xml" title="wycBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    
    <div id="header-inner" class="inner">
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">首页</a>
        
          <a class="main-nav-link" href="/archives">归档</a>
        
          <a class="main-nav-link" href="/about">关于</a>
        
      </nav>
      
    </div>
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">wycBlog</a>
      </h1>
      
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-csdn转移/设计模式--单例模式" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/设计模式--单例模式/" class="article-date">
  <time datetime="2019-04-28T12:31:54.381Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="1-懒汉式–线程不安全"><a href="#1-懒汉式–线程不安全" class="headerlink" title="1.懒汉式–线程不安全"></a>1.懒汉式–线程不安全</h2><h2 id="2-懒汉式–线程安全"><a href="#2-懒汉式–线程安全" class="headerlink" title="2.懒汉式–线程安全"></a>2.懒汉式–线程安全</h2><h2 id="3-饿汉式-线程安全"><a href="#3-饿汉式-线程安全" class="headerlink" title="3.饿汉式(线程安全)"></a>3.饿汉式(线程安全)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-双检锁-双重校验-DCL，即double-checked-locking，线程安全"><a href="#4-双检锁-双重校验-DCL，即double-checked-locking，线程安全" class="headerlink" title="4.双检锁/双重校验(DCL，即double-checked locking，线程安全)"></a>4.双检锁/双重校验(DCL，即double-checked locking，线程安全)</h2><p>双检锁能够在保证线程安全的情况下高性能，voltile 与synchronized配合使用，可以保证操作的原子性</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Stringleton singleton; <span class="comment">//保证每次读取到singleton的值都是最新的</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;  <span class="comment">//原子操作</span></span><br><span class="line">                <span class="keyword">if</span>(singleton ==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    singleton == <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>synchronized</strong> </p>
<p>线程同步</p>
<p>同步块大家都比较熟悉，通过 synchronized 关键字来实现，所有加上synchronized 和 块语句，在多线程访问的时候，同一时刻只能有一个线程能够用。</p>
<p>synchronized 修饰的方法 或者 代码块。</p>
<p><strong>volatile</strong></p>
<p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<ol>
<li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li>禁止进行指令重排序。</li>
<li>不具有原子性</li>
</ol>
<p>先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程1</span></span><br><span class="line"><span class="keyword">boolean</span> stop = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2</span></span><br><span class="line">stop = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p> 　　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<blockquote>
<p>volatile 含义参考<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
</blockquote>
<h2 id="登记式–静态内部类-多线程安全"><a href="#登记式–静态内部类-多线程安全" class="headerlink" title="登记式–静态内部类(多线程安全)"></a>登记式–静态内部类(多线程安全)</h2><p>达到双检锁同样的效果，但是更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式；对实例域需要延迟初始化时使用双检锁方式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123; <span class="comment">//在Singleton类被加载时，instance不一定被初始化。因为Singleton类没有被主动使用。只有调用getInstance()时SingleHolder才会被装载，此时才会创建instance实例。</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTACE =<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-枚举–线程安全"><a href="#6-枚举–线程安全" class="headerlink" title="6. 枚举–线程安全"></a>6. 枚举–线程安全</h2><p>可以说这种方式是最简洁的方法。它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton&#123;</span><br><span class="line">    INSTANCE；</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">whateverMethod</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：一般情况使用方式3和方式5</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/设计模式--单例模式/" data-id="cjv0x6cal001kq8rwmh7cpyh8" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/nodejs笔记1-Buffer" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/nodejs笔记1-Buffer/" class="article-date">
  <time datetime="2019-04-28T12:31:54.377Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个长度为 10、且用 0 填充的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf1 = Buffer.alloc(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span></span><br><span class="line"><span class="keyword">const</span> buf2 = Buffer.alloc(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个长度为 10、且未初始化的 Buffer。</span></span><br><span class="line"><span class="comment">// 这个方法比调用 Buffer.alloc() 更快，</span></span><br><span class="line"><span class="comment">// 但返回的 Buffer 实例可能包含旧数据，</span></span><br><span class="line"><span class="comment">// 因此需要使用 fill() 或 write() 重写。</span></span><br><span class="line"><span class="keyword">const</span> buf3 = Buffer.allocUnsafe(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf4 = Buffer.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf5 = Buffer.from(<span class="string">'tést'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span></span><br><span class="line"><span class="keyword">const</span> buf6 = Buffer.from(<span class="string">'tést'</span>, <span class="string">'latin1'</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//.............写入缓冲区</span></span><br><span class="line"><span class="comment">//写如Node缓冲区的语法如下：</span></span><br><span class="line"><span class="comment">//buf.write(string [,offset[,length]][,encoding]);</span></span><br><span class="line"><span class="comment">//string -写入缓冲区的字符串</span></span><br><span class="line"><span class="comment">//offset -写入的字节数，默认为buffer.length</span></span><br><span class="line"><span class="comment">//encoding -使用的编码，默认为utf8</span></span><br><span class="line"><span class="comment">// --该函数返回值为实际写入大大小</span></span><br><span class="line"></span><br><span class="line">buf =Buffer.alloc(<span class="number">256</span>);</span><br><span class="line">len=buf.write(<span class="string">'www.runoob.com'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"写入字节数："</span>+len);</span><br><span class="line"></span><br><span class="line"><span class="comment">//..............从缓冲区读取数据</span></span><br><span class="line"><span class="comment">// buf.toString([encoding[,start[,end]]]);</span></span><br><span class="line"><span class="comment">//encoding - 使用的编码，默认为utf8</span></span><br><span class="line"><span class="comment">//start - 指定开始读取索引的位置</span></span><br><span class="line"><span class="comment">//end - 结束的位置，默认为缓冲区的末尾</span></span><br><span class="line"><span class="comment">//-----返回值———— 解码缓冲区数据并使用指定的编码返回字符串</span></span><br><span class="line"></span><br><span class="line">buf =Buffer.alloc(<span class="number">26</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;<span class="number">26</span>;i++)&#123;</span><br><span class="line">    buf[i]=i+<span class="number">97</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'ascii'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'ascii'</span>,<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="string">'utf8'</span>,<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"><span class="built_in">console</span>.log(buf.toString(<span class="literal">undefined</span>,<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//缓冲区合并</span></span><br><span class="line"><span class="comment">//Buffer.concat(list[,totalLength]);</span></span><br><span class="line"><span class="comment">//list - 用于合并Buffer对象的数组</span></span><br><span class="line"><span class="comment">//totalLength - 指定合并后Buffer对象的总长度</span></span><br><span class="line"><span class="comment">//...返回值,多个成员合并后的新对象</span></span><br><span class="line"><span class="keyword">var</span> buffer1=Buffer.from(<span class="string">'菜鸟教程'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2=Buffer.from(<span class="string">'www.runoob.com'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer3=Buffer.concat([buffer1,buffer2]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'buffer3内容:'</span>+buffer3.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//.....缓冲区裁剪</span></span><br><span class="line"> <span class="comment">//buf.slice([start[,end]]);</span></span><br><span class="line"> <span class="comment">//start - 数字，可选，默认为0</span></span><br><span class="line"> <span class="comment">//end - 数字，可选，默认：buffer.length</span></span><br><span class="line"> <span class="comment">//返回值，返回一个新的缓冲区，它和旧的缓冲区指向同一块内存。</span></span><br><span class="line"><span class="keyword">var</span> buffer1=Buffer.from(<span class="string">'runoob'</span>);</span><br><span class="line"><span class="keyword">var</span> buffer2=buffer1.slice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'buffer2 content:'</span>+buffer2.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//....缓冲区长度</span></span><br><span class="line"><span class="comment">//buf.length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//方法参考</span></span><br><span class="line"><span class="comment">//Node.js Buffer 常用方法：</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//将Buffer转化为JSON对象</span></span><br><span class="line"><span class="comment">//buf.toJSON();</span></span><br><span class="line"><span class="comment">//当字符串化一个Buffer实例时，JSON.stringify()会隐式的调用toJSON()方法</span></span><br><span class="line"><span class="keyword">const</span> buf=Buffer.from([<span class="number">0x1</span>,<span class="number">0x2</span>,<span class="number">0x3</span>,<span class="number">0x4</span>]);</span><br><span class="line"><span class="keyword">const</span> json=<span class="built_in">JSON</span>.stringify(buf);</span><br><span class="line"><span class="built_in">console</span>.log(json);</span><br><span class="line"></span><br><span class="line">cosnt copy=<span class="built_in">JSON</span>.parse(json,(key,value)=&gt;&#123;</span><br><span class="line">    <span class="keyword">return</span> value &amp;&amp; value.type === <span class="string">'Buffer'</span> ? Buffer.from(value.data) : value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(copy);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/nodejs笔记1-Buffer/" data-id="cjv0x6ca4000vq8rw0yn37w38" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/使用Express框架开发网站" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/使用Express框架开发网站/" class="article-date">
  <time datetime="2019-04-28T12:31:54.373Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="使用Exprss项目生成器来快速生成Express项目"><a href="#使用Exprss项目生成器来快速生成Express项目" class="headerlink" title="使用Exprss项目生成器来快速生成Express项目"></a>使用Exprss项目生成器来快速生成Express项目</h2><p>首先安装Express:</p>
<p><code>npm install -g expess</code></p>
<p>接着安装express-generator</p>
<p><code>npm install -g express-generator</code></p>
<p>然后使用命令生成一个模板</p>
<p><code>express -e blog</code></p>
<p>该条命令用于生成一个名为blog的模板，模板的文件目录如下：</p>
<ul>
<li>bin    –存放连接数据库的操作</li>
<li>public  –存放静态资源文件，css，图片等</li>
<li>routes –路由文件，存放js程序，用来分析客户端发来的post和get命令</li>
<li>views –ejs模板文件，存放ejs模板编写的前端页面</li>
<li>app.js –程序的入口</li>
<li>package.json –存放配置信息，保存各个依赖包的版本信息等</li>
</ul>
<p>app.js文件中的代码如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> createError = <span class="built_in">require</span>(<span class="string">'http-errors'</span>);</span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">'cookie-parser'</span>);</span><br><span class="line"><span class="keyword">var</span> logger = <span class="built_in">require</span>(<span class="string">'morgan'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> indexRouter = <span class="built_in">require</span>(<span class="string">'./routes/index'</span>);</span><br><span class="line"><span class="keyword">var</span> usersRouter = <span class="built_in">require</span>(<span class="string">'./routes/users'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置视图文件夹的位置</span></span><br><span class="line">app.set(<span class="string">'views'</span>, path.join(__dirname, <span class="string">'views'</span>));</span><br><span class="line"><span class="comment">// 设置视图文件使用ejs模板</span></span><br><span class="line">app.set(<span class="string">'view engine'</span>, <span class="string">'ejs'</span>);</span><br><span class="line"><span class="comment">// 使用日志记录中间件</span></span><br><span class="line">app.use(logger(<span class="string">'dev'</span>));</span><br><span class="line"><span class="comment">// 使用express中间件</span></span><br><span class="line">app.use(express.json());</span><br><span class="line">app.use(express.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line"><span class="comment">// 使用cookieParser中间件</span></span><br><span class="line">app.use(cookieParser());</span><br><span class="line"><span class="comment">// 使用express默认的static中间件设置静态资源文件夹的位置</span></span><br><span class="line">app.use(express.static(path.join(__dirname, <span class="string">'public'</span>)));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用路由index</span></span><br><span class="line">app.use(<span class="string">'/'</span>, indexRouter);</span><br><span class="line"><span class="comment">// 使用路由users</span></span><br><span class="line">app.use(<span class="string">'/users'</span>, usersRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理404错误</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  next(createError(<span class="number">404</span>));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理错误</span></span><br><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 设置本地错误仅仅在在开发环境中提供</span></span><br><span class="line">  res.locals.message = err.message;</span><br><span class="line">  res.locals.error = req.app.get(<span class="string">'env'</span>) === <span class="string">'development'</span> ? err : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 渲染错误请求页面</span></span><br><span class="line">  res.status(err.status || <span class="number">500</span>);</span><br><span class="line">  res.render(<span class="string">'error'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = app;</span><br></pre></td></tr></table></figure></p>
<p>在app.js中添加如下代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app。listen(<span class="number">3000</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'listening port 3000'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>然后就可以通过node app命令来启动服务器，在浏览器中输入localhost:3000/来进访问。当然此时的服务器只有一个空的主页和一个404错误页面。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/使用Express框架开发网站/" data-id="cjv0x6cad0018q8rwjopteura" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/nodejs笔记2-Stream" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/nodejs笔记2-Stream/" class="article-date">
  <time datetime="2019-04-28T12:31:54.365Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h2 id="Node-js-Stream流"><a href="#Node-js-Stream流" class="headerlink" title="Node.js Stream流"></a>Node.js Stream流</h2><p>Stream是一个抽象接口，Node中有很多对象实现了这个接口。例如:对Http发起请求的request对象就是一个Stream，还有stdout.<br>Node.js Stream有四种类型：</p>
<ol>
<li>Readable-可读操作</li>
<li>Writable-可写操作</li>
<li>Dyplex-可读写操作</li>
<li>Transform-操作被写入的数据然后读出结果</li>
</ol>
<p>所有的Stream对象都是EventEmitter的实例。常用的时间有：</p>
<ol>
<li>data-当有数据可读时触发。</li>
<li>end-没有更多数据可读时触发。</li>
<li>error-在接收和写入的过程中发生错误时触发。</li>
<li>finish-所有数据已经被写入到底层系统时触发。</li>
</ol>
<h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);<span class="comment">//创建流</span></span><br><span class="line"><span class="keyword">var</span> data=<span class="string">''</span>;</span><br><span class="line"><span class="comment">//创建可读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream=fs.createReadStream(<span class="string">'input.txt'</span>);<span class="comment">//从文件中创建可读流。</span></span><br><span class="line"><span class="comment">//设置编码为utf8</span></span><br><span class="line">readerStream.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line"><span class="comment">//处理流事件</span></span><br><span class="line">readerStream.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">chunk</span>)</span>&#123;</span><br><span class="line">    data+=chunk;</span><br><span class="line">&#125;);</span><br><span class="line">readStream.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">readerStream.on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">er</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">"fs"</span>);</span><br><span class="line"><span class="keyword">var</span> data=<span class="string">"这是一个写入流的演示实例"</span>;</span><br><span class="line"><span class="comment">//创建写入流，写入到文件output.txt中</span></span><br><span class="line"><span class="keyword">var</span> writerStream =fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"><span class="comment">//使用utf8编码写入数据</span></span><br><span class="line">writerStream.write(data,<span class="string">'utf8'</span>);</span><br><span class="line"><span class="comment">//标记文件末尾</span></span><br><span class="line">writerStream.end();</span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>管道流提供了一个输出流到输入流的机制。通常我们用于将一个流中获取的数据传递到 另外一个流。<br><em>下面的例子中我们使用流从一个文件中读取后复制到另外一个  文件中去。</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="comment">//创建一个读流</span></span><br><span class="line"><span class="keyword">var</span> readerStream=fs.createReadStream(<span class="string">'input.txt'</span>);</span><br><span class="line"><span class="comment">//创建一个可写流</span></span><br><span class="line"><span class="keyword">var</span> writerStream=fs.createWriteStream(<span class="string">'output.txt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//管道读写操作,将读取的文件写入到output.txt中</span></span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"程序执行完毕"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式流是链接输出流到另外一个流并创建多个流的操作的机制。<br>下面是利用管道和压缩和解压文件。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> fs=<span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> zlib=<span class="built_in">require</span>(<span class="string">'zlib'</span>);</span><br><span class="line"><span class="comment">//压缩input.txt文件为input.txt.gz</span></span><br><span class="line">fs.createReadStream(<span class="string">'input.txt'</span>)</span><br><span class="line">    .pipe(zlib.createGzip())       <span class="comment">//先输出到压缩流，</span></span><br><span class="line">    .pipe(fs.createWriteStream(<span class="string">'imput.txt.gz'</span>));<span class="comment">//再输出到写入流</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'文件压缩完成'</span>);</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/nodejs笔记2-Stream/" data-id="cjv0x6ca5000xq8rw4uswx0t9" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/css笔记--css中需要注意的知识点" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/css笔记--css中需要注意的知识点/" class="article-date">
  <time datetime="2019-04-28T12:31:54.357Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="css笔记–css中需要注意的知识点"><a href="#css笔记–css中需要注意的知识点" class="headerlink" title="css笔记–css中需要注意的知识点"></a>css笔记–css中需要注意的知识点</h1><h2 id="css尺寸"><a href="#css尺寸" class="headerlink" title="css尺寸"></a>css尺寸</h2><p>css的尺寸属性</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>height</td>
<td>设置元素的高度</td>
</tr>
<tr>
<td>width</td>
<td>设置宽度</td>
</tr>
<tr>
<td>line-hight</td>
<td>设置元素行高</td>
</tr>
<tr>
<td>max-height</td>
<td>设置元素的最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>设置最大宽度</td>
</tr>
<tr>
<td>min-height</td>
<td>最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>最小宽度</td>
</tr>
</tbody>
</table>
<p>尺寸属性可以设置为具体的像素单位，也可以设置为相对父元素尺寸的百分比</p>
<p>max-height和max-width属性是当图片的高和宽超过了设定的最大值时，按最大值显示，若没有超过最大值，则最大值不影响大小。</p>
<h2 id="display属性"><a href="#display属性" class="headerlink" title="display属性"></a>display属性</h2><p>display属性用于设置元素的状态</p>
<p>display:none或设置visibility:hidden，使元素不可见。但是这两个方法是有区别的，display:none设置后元素不再占用空间，而visibility:hidden设置后，元素还会占用空间，即使它不再显示。</p>
<p><strong>内联元素和块级元素</strong></p>
<ul>
<li>块级元素：独占一行，比如：<code>&lt;div&gt;div1&lt;/div&gt;&lt;div&gt;div2&lt;/div&gt;</code>会显示成两行。块级元素的width、height、padding、margin属性都是可控制的。即，我们可以给这些属性指定具体的值。</li>
<li>内联元素：相邻的内联元素将显示在同一行，比如：<code>&lt;span&gt;span1&lt;/span&gt;&lt;span&gt;span2&lt;/span&gt;</code>会显示在同一行。内联元素的width、height、padding、margin等都不可改变。</li>
</ul>
<p>元素分类：</p>
<ul>
<li>块级元素有：address, blockquote, center, dir, div, dl, fieldset, form, h1, h2, h3, h4, h5, h6, hr, isindex, menu, noframes, noscript, ol, p, pre, table, ul, li</li>
<li>内联元素：a, abbr, acronym, b, bdo, big, br, cite, code, dfn, em, font, i, img, input, kbd, label, q, s, samp, select, small, span, strike, strong, sub, sup, txtarea, tt, u, var</li>
<li>可变元素：applet, button, del, iframe, ins, map, object, script</li>
</ul>
<p>虽然元素有其分类，但是我们可以用display元素修改它们的默认分类。</p>
<ul>
<li>dispaly:block 显示为块级元素</li>
<li>display:inline 显示为行级元素</li>
<li>display:inline-block 显示为内联元素，但是可以修改其高宽、边距等</li>
</ul>
<p>display:inline-block常常用在<code>&lt;ul&gt;</code>元素，使ul变成水平显示，而且可以调整它的盒子模型</p>
<h2 id="position定位"><a href="#position定位" class="headerlink" title="position定位"></a>position定位</h2><p>position属性有5个值</p>
<ul>
<li>static 使用html默认</li>
<li>relative 相对该元素正常位置的重新定位</li>
<li>fixed 相对浏览器窗口是固定的</li>
<li>absolute 绝对定位，相对父元素的定位</li>
<li>sticky(粘性的) 基于用户的滚动位置来定位。常见的网页中有header，下面有navbar，向上滚动时，navbar会固定在浏览时上方，这种便用到的sticky属性。</li>
</ul>
<p><strong>sticky属性详细说明</strong></p>
<p>元素定义了sticky之后必须指定阈值top，right，bottom，left四个中的一个，以指定固定在浏览器的哪个方向上。否则不会生效。</p>
<p>举例：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sticky</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: -webkit-sticky; <span class="comment">/* Safari */</span></span><br><span class="line">    <span class="attribute">position</span>: sticky;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: green;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#4CAF50</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当为元素指定了position后，有如下的定位属性可选择。</p>
<ul>
<li>bottom </li>
<li>right</li>
<li>left</li>
<li>top</li>
<li>clip  裁剪一个绝对定位的元素，有三个值:shape,auto,inherit; shape(只有一个形状rect,使用clip:rect (top, right, bottom, left));auto 表示默认值,inherit 从父元素继承</li>
<li>cursor 显示光标移动到指定的类型 参考&gt;<a href="http://www.runoob.com/css/css-positioning.html" target="_blank" rel="noopener">http://www.runoob.com/css/css-positioning.html</a></li>
<li>overflow 设置当元素的内容溢出其区域时发生的事情。</li>
<li>overflow-y  指定如何处理顶部/底部边缘的内容溢出元素的内容区域</li>
<li>overflow-x </li>
<li>z-index 设置元素的堆叠顺序</li>
</ul>
<p>该部分参考 &gt;<a href="http://www.runoob.com/css/css-positioning.html" target="_blank" rel="noopener">http://www.runoob.com/css/css-positioning.html</a></p>
<h2 id="float浮动"><a href="#float浮动" class="headerlink" title="float浮动"></a>float浮动</h2><p>会使元素向左或向右移动，其周围的元素也会重新排列。<br>Float（浮动），往往是用于图像，但它在布局时一样非常有用。</p>
<p>float:left/right/none/inherit</p>
<p>clear:left/right/both/none/inerit 清除指定元素周围的浮动</p>
<h2 id="设置背景图"><a href="#设置背景图" class="headerlink" title="设置背景图"></a>设置背景图</h2><p>background: url(图片地址) 0 0;  后面两个参数表示从什么位置开始裁剪</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/css笔记--css中需要注意的知识点/" data-id="cjv0x6c9z000nq8rwr6yjogpw" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/Ubuntu系统基础知识" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/Ubuntu系统基础知识/" class="article-date">
  <time datetime="2019-04-28T12:31:54.349Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="Ubuntu系统学习"><a href="#Ubuntu系统学习" class="headerlink" title="Ubuntu系统学习"></a>Ubuntu系统学习</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="Ubuntu-目录和文件系统"><a href="#Ubuntu-目录和文件系统" class="headerlink" title="Ubuntu 目录和文件系统"></a>Ubuntu 目录和文件系统</h3><ul>
<li>/bin –重要的二进制应用程序</li>
<li>/boot –启动配置文件</li>
<li>/dec –设备文件</li>
<li>/etc –配置文件、启动脚本等</li>
<li>/home –本地用户主目录</li>
<li>/lib –系统库文件</li>
<li>/lost+found –在更目录下提供一个遗失查找系统</li>
<li>/media –挂载可移动介质，如U盘等，安装双系统时win10的其他盘也会在这个目录下</li>
<li>/mnt –挂载（mounted）文件系统</li>
<li>/opt –提供一个可选应用程序安装目录</li>
<li>/proc –特殊的动态目录，用于维护系统信息和状态</li>
<li>/root –root用户的主文件夹</li>
<li>/sbin –重要的系统二进制文件（system binaries）</li>
<li>/sys –系统文件</li>
<li>/tmp –临时文件（temporary）</li>
<li>/user –绝大多数用户都可以访问的应用程序和文件</li>
<li>/var –经常变化的文件（variable），比如日志文件</li>
</ul>
<h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><p>Linux 系统上所有文件都有权限。root用户可以访问系统任意文件。每个文件都有三组保护权限<br>依次为：</p>
<ul>
<li>用户 user    –适用于该文件打所有者</li>
<li>组 group –适用于该文件所属的组</li>
<li>其他other  –适用于所有用户</li>
</ul>
<p>上述三组权限每一组又含有一下三种读写控制</p>
<ul>
<li>读 read</li>
<li>写 write</li>
<li>可执行 execute</li>
</ul>
<p>文件所有者可以编辑授权等级：右键&gt;属性&gt;权限</p>
<h3 id="root和sudo"><a href="#root和sudo" class="headerlink" title="root和sudo"></a>root和sudo</h3><p>ubuntu使用sudo命令来执行root管理员任务<br>sudo + 命令  ;或者使用sudo -i 或者sudo su，将终端设置成root账户；exit推出root账户</p>
<h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><h4 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h4><p>快捷键：</p>
<ul>
<li>ctrl+alt+t 打开一个终端   </li>
<li>ctrl+shift+t 在当前终端窗口中再打开一个终端</li>
</ul>
<h4 id="常用的命令"><a href="#常用的命令" class="headerlink" title="常用的命令"></a>常用的命令</h4><ul>
<li>切换到 root 用户 ，输入 “sudo -i ”或“sudo su -”, 退出 “exit”</li>
<li>查看目录：ls<ul>
<li>列出当前目录下的文件</li>
</ul>
</li>
<li>创建目录：mkdir dirname<ul>
<li>创建一个目录</li>
</ul>
</li>
<li>切换目录：cd (directory/location)创建目录<ul>
<li>cd ../ 打开上级目录</li>
<li>cd ./filepath 打开当前目录为根目录打文件</li>
</ul>
</li>
<li>复制文件/目录：cp (源文件/目录)(目标文件/目录)<ul>
<li>cp filepathA  filepathB 将文件A复制到文件B</li>
<li>cp -r 目录A  目录B 将目录A复制到目录B</li>
</ul>
</li>
<li>删除文件/目录：rm (目录或者文件)<ul>
<li>rm 可以删除您指定的任意文件</li>
<li>rm -rf 可以删除指定的任意目录</li>
<li>rmdir 删除空文件夹</li>
</ul>
</li>
<li>重命名文件/目录：mv (文件名或目录名)<ul>
<li>mv [选项] 源文件或目录 目标文件或目录  移动目录或重命名目录</li>
<li>b ：若需覆盖文件，则覆盖前先行备份。 </li>
<li>f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li>
<li>i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li>
<li>u ：若目标文件已经存在，且 source 比较新，才会更新(update)</li>
<li>t  ： –target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</li>
</ul>
</li>
<li>移动多个文件：<ul>
<li>mv log1.txt log2.txt log3.txt test3 将 log1.txt log2.txt log3.txt 三个文件移动到目录test3下</li>
<li>mv t /opt/soft/test/test4/ log1.txt log2.txt log3.txt test3 将 log1.txt log2.txt log3.txt test3移动到目录text4下</li>
</ul>
</li>
<li>查找文件/目录：locate (文件名或者目录名)<ul>
<li>locate 命令会在您的计算机里搜索您指定的任意文件。它使用您系统中的文件索引以便进行快速查找：运行命令 updatedb 可以更新该索引。每天您一开机，该命令便会（在合适的时机）自动运行。运行该命令需要具备管理员权限 (参见 第1.3.3节 ― root 用户和 sudo 命令)。可以使用通配符来匹配一个或多个文件，如 “*” (匹配所有文件) 或 “?” (匹配一个字符)。</li>
</ul>
</li>
<li>man 显示某个命令的手册 manual</li>
<li>df 显示文件系统空间信息<ul>
<li>df -h  用 M 和 G 做单位显示文件系统空间信息 -h 意思是 human-readable </li>
</ul>
</li>
<li>du 显示目录的空间使用信息<ul>
<li>du -sh /media/floppy    ;  -s 意思 summary摘要   -h 意思 human-readable容易阅读的 </li>
</ul>
</li>
<li>ifconfig 显示系统的网络</li>
<li></li>
</ul>
<h4 id="切换到控制台"><a href="#切换到控制台" class="headerlink" title="切换到控制台"></a>切换到控制台</h4><p>ctrl+alt+f1到ctrl+atl+f6切换到控制他系统，最多支持6个用户。ctrl+atl+f7退出控制台系统。</p>
<h2 id="添加和删除应用程序"><a href="#添加和删除应用程序" class="headerlink" title="添加和删除应用程序"></a>添加和删除应用程序</h2><p>有三种方法可以添加或者删除应用程序：</p>
<ol>
<li>使用系统自带的应用商店</li>
<li>使用Synaptic（新立得软件管理器）</li>
<li>APT包管理器</li>
</ol>
<h3 id="Synaptic"><a href="#Synaptic" class="headerlink" title="Synaptic"></a>Synaptic</h3><p>安装新立得</p>
<p><code>sudo apt-get install synaptic</code></p>
<h3 id="APT"><a href="#APT" class="headerlink" title="APT"></a>APT</h3><ul>
<li>安装软件：<code>sudo apt-get install packagename</code></li>
<li>删除软件：<code>sudo apt-get remove packagename</code></li>
<li>更新软件包列表：<code>sudo apt-get update</code></li>
<li>将所有软件更新：<code>sudo apt-get upgrade</code></li>
<li>列出更多的命令和选项：<code>apt-get help</code></li>
</ul>
<h3 id="安装从网上下载的软件压缩包"><a href="#安装从网上下载的软件压缩包" class="headerlink" title="安装从网上下载的软件压缩包"></a>安装从网上下载的软件压缩包</h3><h3 id="安装-deb-后缀的软件包"><a href="#安装-deb-后缀的软件包" class="headerlink" title="安装 .deb 后缀的软件包"></a>安装 .deb 后缀的软件包</h3><ol>
<li>直接双击然或点击安装</li>
<li>使用终端安装<code>sudo dpkg -i packge_file.deb</code></li>
<li>使用终端卸载`sudo dpkg -r package-name</li>
</ol>
<h3 id="将-rpm文件转为-deb-文件"><a href="#将-rpm文件转为-deb-文件" class="headerlink" title="将.rpm文件转为 .deb 文件"></a>将.rpm文件转为 .deb 文件</h3><ol>
<li>首先安装alien程序`sudo apt-get install alien</li>
<li>在终端中使用alien程序将.rpm转换为.deb：<code>sudo alien pacckage_file.rpm</code></li>
</ol>
<h3 id="安装tarballs"><a href="#安装tarballs" class="headerlink" title="安装tarballs"></a>安装tarballs</h3><p>.tar.zg或者.tar.bz2作为后缀的文件啥在Linux和Unix中被广泛使用的tarballs的打包文件。Tarballs通常包含源代码，需要编译后才能使用。<br>。。。。。。</p>
<h3 id="软件库"><a href="#软件库" class="headerlink" title="软件库"></a>软件库</h3><p>系统设置&gt;系统&gt;软件和更新&gt;Ubuntu软件：</p>
<p><img src="https://img-blog.csdn.net/20180928093130590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<ul>
<li>要启用 Universe 软件库，请勾选 社区维护 (Universe) 按钮。<ul>
<li>添加这个软件库将意味着世界上大多数的自由软件都可以安装在您系统中。该软件被 Ubuntu 社区志愿者中选出的小组支持，但并不被 Ubuntu核心开发团队支持，同时也许没有包括安全更新。</li>
</ul>
</li>
<li>要启用 Multiverse 软件库，请勾选 非自由 (Multiverse) 按钮。<ul>
<li>添加这个软件库将意味着被归为 非自由 类的软件可以安装在您系统中。该软件可能在某些区域可能不被允许。当从该软件库中安装每一个软件包时，您将确保您国家的法律允许您使用它。重复一遍，该软件也许没有包括安全更新。</li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/Ubuntu系统基础知识/" data-id="cjv0x6c9v000iq8rwoi2b3v70" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/shell学习之shell变量" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/shell学习之shell变量/" class="article-date">
  <time datetime="2019-04-28T12:31:54.341Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><p>shell是一个用c语言编写的程序，是用户用来操作linux系统的语言，俗称命令行。</p>
<h2 id="我的第一个shell脚本"><a href="#我的第一个shell脚本" class="headerlink" title="我的第一个shell脚本"></a>我的第一个shell脚本</h2><p>新建一个文本，将其命名为test.sh。在文本中编写代码：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">！/bin/bash</span></span><br><span class="line">echo “hello wang”</span><br></pre></td></tr></table></figure>
<p>在test.sh文件夹中打开终端输入<code>bash test.sh</code> 或者 <code>./test.sh</code> 就可以运行脚本。</p>
<h2 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h2><p>定义变量时，变量名不能加美元符号：</p>
<p><code>my_name = &quot;wycan&quot;</code></p>
<p>注意：</p>
<ol>
<li>变量名自能是英文字母、数字和下划线的组合，首字母不能以数字开头。</li>
<li>变量名中间不能有空格，一般使用下划线链接</li>
<li>不能使用bash保留的关键字</li>
<li>不能使用标点符号</li>
</ol>
<p>除了使用显示赋值，还可以使用语句赋值：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in 'ls /etc'</span><br><span class="line">或者</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>变量定义后，如果要使用变量，需要在变量前加上# ,这于其他编程语言有所不同。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#！/bin/bash</span></span><br><span class="line">my_name=<span class="string">"wycan"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;my_name&#125;</span></span><br></pre></td></tr></table></figure>
<p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> skill <span class="keyword">in</span> Ada Coffe Action Java; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"I am good at <span class="variable">$&#123;skill&#125;</span>Script"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>使用readonly命令可以将变量定义为只读变量，只读变量的值不能被改变。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">my_name=<span class="string">"wycan"</span></span><br><span class="line"><span class="built_in">readonly</span> myUrl</span><br><span class="line">my_name=<span class="string">"wycan"</span>    //在这里尝试修改会出错</span><br></pre></td></tr></table></figure>
<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>使用unset命令可以删除变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">my_name=<span class="string">"wycan"</span></span><br><span class="line"><span class="built_in">unset</span> my_name</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$my_name</span></span><br></pre></td></tr></table></figure>
<p>该代码不会输出任何信息</p>
<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><ol>
<li>局部变量 <ul>
<li>局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。–局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li>
</ul>
</li>
<li>环境变量<ul>
<li>所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li>
</ul>
</li>
<li>shell变量<ul>
<li>shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li>
</ul>
</li>
</ol>
<h3 id="shell中的字符串"><a href="#shell中的字符串" class="headerlink" title="shell中的字符串"></a>shell中的字符串</h3><p>shell中字符串可以使用单引号也可以使用双引号</p>
<p>但是shell对单引号是有限制的</p>
<ul>
<li>单引号中的字符串会原样输出，不会识别其中的变量</li>
<li>单引号字符串中不能出现单独的单引号</li>
</ul>
<p>双引号：</p>
<ul>
<li>双引号里可以有变量</li>
<li>双引号里可以出现转义符</li>
</ul>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name=<span class="string">'wycan'</span></span><br><span class="line">str=<span class="string">"hello my name is <span class="variable">$&#123;my_name&#125;</span> ! \n"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$str</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><code>hello my name is wycan</code></p>
<h3 id="拼接字符串"><a href="#拼接字符串" class="headerlink" title="拼接字符串"></a>拼接字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bin/bash</span></span><br><span class="line">your_name=<span class="string">"runoob"</span></span><br><span class="line"><span class="comment"># 使用双引号拼接</span></span><br><span class="line">greeting=<span class="string">"hello, "</span><span class="variable">$your_name</span><span class="string">" !"</span></span><br><span class="line">greeting_1=<span class="string">"hello, <span class="variable">$&#123;your_name&#125;</span> !"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting</span>  <span class="variable">$greeting_1</span></span><br><span class="line"><span class="comment"># 使用单引号拼接</span></span><br><span class="line">greeting_2=<span class="string">'hello, '</span><span class="variable">$your_name</span><span class="string">' !'</span></span><br><span class="line">greeting_3=<span class="string">'hello, $&#123;your_name&#125; !'</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$greeting_2</span>  <span class="variable">$greeting_3</span></span><br></pre></td></tr></table></figure>
<p>输出结果为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob ! hello, runoob !</span><br><span class="line">hello, runoob ! hello, <span class="variable">$&#123;your_name&#125;</span> !</span><br></pre></td></tr></table></figure></p>
<h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"wycan"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#str&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出：4</p>
<h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str=<span class="string">"study shell is wery happy"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;str:1:4&#125;</span></span><br></pre></td></tr></table></figure>
<p>输出 tudy</p>
<h3 id="查找子字符串"><a href="#查找子字符串" class="headerlink" title="查找子字符串"></a>查找子字符串</h3><p>查找字符 i 或 o 的位置(哪个字母先出现就计算哪个)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"runoob is a great site"</span></span><br><span class="line"><span class="built_in">echo</span> `expr index <span class="string">"<span class="variable">$string</span>"</span> io`</span><br></pre></td></tr></table></figure></p>
<p> 输出 4<br>需要注意的是<code>echo `expr index &quot;$string&quot; io`</code> 中不是单引号<code>‘</code> ，而是反引号<code>`</code></p>
<h3 id="shell数组"><a href="#shell数组" class="headerlink" title="shell数组"></a>shell数组</h3><p>bash只支持一维数组，并且不限制数组的大小，数组下标从0开始</p>
<h4 id="定义数组"><a href="#定义数组" class="headerlink" title="定义数组"></a>定义数组</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure>
<h4 id="读取数组"><a href="#读取数组" class="headerlink" title="读取数组"></a>读取数组</h4><p><code>${数组名[下标]}</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value=<span class="variable">$&#123;array_name[0]&#125;</span>    <span class="comment"># 读取数组的第一个</span></span><br></pre></td></tr></table></figure>
<p><strong>使用@符号可以获取数组中所有元素</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value=<span class="variable">$&#123;array_name[@]&#125;</span></span><br></pre></td></tr></table></figure>
<h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取得数组元素的个数</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[@]&#125;</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">length=<span class="variable">$&#123;#array_name[*]&#125;</span></span><br><span class="line"><span class="comment"># 取得数组单个元素的长度</span></span><br><span class="line">lengthn=<span class="variable">$&#123;#array_name[n]&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="shell-注释"><a href="#shell-注释" class="headerlink" title="shell 注释"></a>shell 注释</h3><p>shell有三种注释方法</p>
<p>1.单行注释， 以<code>#</code> 开头的行就是注释，会被解释器忽略<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是注释内容</span></span><br></pre></td></tr></table></figure></p>
<ol start="2">
<li>多行注释格式1<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br><span class="line">```	</span><br><span class="line"></span><br><span class="line">3. 多行注释2</span><br><span class="line">```bash</span><br><span class="line">:&lt;&lt;<span class="string">'</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">注释内容...</span></span><br><span class="line"><span class="string">'</span></span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/shell学习之shell变量/" data-id="cjv0x6ca90013q8rwrwo5botk" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/数学问题的解题窍门——辗转相除法" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/数学问题的解题窍门——辗转相除法/" class="article-date">
  <time datetime="2019-04-28T12:31:54.337Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="辗转相除法"><a href="#辗转相除法" class="headerlink" title="辗转相除法"></a>辗转相除法</h1><h2 id="求最大公约数"><a href="#求最大公约数" class="headerlink" title="求最大公约数"></a>求最大公约数</h2><p>问题：线上格点的个数</p>
<p>给定平面上两个格点（格点是指纵横坐标都为整数的点）$P_1=(x_1,y_2),P_1=(x_2,y_2)$ ,线段$P_1P_2$ 上，除了$P_1，P_2$还有多少个格点？？</p>
<p>限制条件：</p>
<p><strong>$-10^9\leqslant x_1,x_2,y_1,y_2 \leqslant 10^9$</strong></p>
<p>输入样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1= 1 11   </span><br><span class="line">p2= 5 3</span><br></pre></td></tr></table></figure></p>
<p>输出样例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(2,9) (3,7) (4,5)</span><br><span class="line">3个格点</span><br></pre></td></tr></table></figure></p>
<p>这道题目解答并不困难，首先我们立马就能想到寻找$x_1和x_2$之间的整数、$y_1,y_2$间的整数。然后检查所有的点是否在直线$P_1P_2$上。虽然可以求出答案，但是时间复杂度较大，并不是一个好办法。</p>
<p>这个题目其实可以利用最大公约数求解。</p>
<p>求a,b最大公约数的辗转相除法：</p>
<ol>
<li>x=max(a,b)    y=min(a,b)</li>
<li>y=x%y ,x=y</li>
<li>如果y!=0 ,则重复步骤2否则最大公约数为x</li>
</ol>
<p>编写函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//求最大公约数的递归算法</span><br><span class="line">int gcd(x,y)&#123;   //x&gt;=y</span><br><span class="line">	if(y==0)return x;</span><br><span class="line">	return gcd(y,x%y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本题中所求的格点个数=$(|x_1-x_2|与|y_1-y_2|的最大公约数)-1$</strong></p>
<p><strong>为啥最大公约数-1就是格点的个数呢？？</strong><br>以本题的示例输入为例，可以这样考虑：<br>8,4的最大公约数是4,说明8%4=0，4%4=0;<br>所以8和4都可以均分为4份，如下图所示：</p>
<p><img src="https://img-blog.csdn.net/20180929184203890?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>将横纵坐标都4等分，发现在线段内正好有三个点，而且每个点的横纵坐标都是整数，所以就有三个格点。<br><img src="https://img-blog.csdn.net/20180929184210560?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI4MTIwNjcz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="在这里插入图片描述"></p>
<p>在本例中|x_1-x_2|=4与|y_1-y_2|=8,最大公约数为4,所以有3个格点。</p>
<p>代码如下;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(y, x % y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出格点</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">printGridPoint</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"("</span> + to_string(x) + <span class="string">","</span> + to_string(y) + <span class="string">")"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"P1="</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x1 &gt;&gt; y1;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"P2="</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x2 &gt;&gt; y2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = max(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">    <span class="keyword">int</span> y = min(<span class="built_in">abs</span>(x1 - x2), <span class="built_in">abs</span>(y1 - y2));</span><br><span class="line">    <span class="keyword">int</span> num = gcd(x, y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> stepX = (x1 - x2) / num;</span><br><span class="line">    <span class="keyword">int</span> stepY = (y1 - y2) / num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; printGridPoint(x2 + stepX * i, y2 + stepY * i) &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (num - <span class="number">1</span>) &lt;&lt; <span class="string">"个格点"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/数学问题的解题窍门——辗转相除法/" data-id="cjv0x6caf001cq8rwf2y569ew" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/cmake 学习" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/cmake 学习/" class="article-date">
  <time datetime="2019-04-28T12:31:54.337Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h1><h2 id="什么是cmake"><a href="#什么是cmake" class="headerlink" title="什么是cmake"></a>什么是cmake</h2><p>c/c++的编译工具有多种，例如：GNU make，QT的qmake，微软的 msmake等。各种make工具的跨平台支持并不好。</p>
<p>cmake就是专门针对跨平台而设计的，它首先允许开发者编写一种平台无关的CMakeLists.txt文件来制定整个编译流程，然后根据目标用户的平台进一步生成本地需要的Makefile文件。</p>
<p>在linux平台下使用CMake并编译流程：</p>
<ol>
<li>编写CMake配置文件CmakeLists.txt</li>
<li>执行<code>cmake path</code> 或者<code>ccmake path</code> 生成Makefile文件。<code>path</code>是CMakeLists.txt所在的目录。</li>
<li>使用<code>make</code>命令进行编译</li>
</ol>
<h2 id="单个文件的情况"><a href="#单个文件的情况" class="headerlink" title="单个文件的情况"></a>单个文件的情况</h2><p>如果我们只有一个main.cpp文件</p>
<p>编写CMakeLists文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#Cmake 最低版本要求</span><br><span class="line">cmake——minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line">#项目信息--项目名称</span><br><span class="line">project (projectDemo)</span><br><span class="line"></span><br><span class="line">#指定生成目标--将main.cpp编译成Demo可执行文件</span><br><span class="line">add——executable(Demo mian.cpp)</span><br></pre></td></tr></table></figure></p>
<p>在当前项目中执行<code>cmake .</code> ，会发现文件夹中多出来几个文件cmakeCache.txt , cmake_install.cmake, CMakefiles</p>
<p>然后执行<code>make</code>命令，编译出可执行文件：Demo</p>
<p>最后运行Demo  ，<code>./Demo</code></p>
<h2 id="同一个目录多个文件"><a href="#同一个目录多个文件" class="headerlink" title="同一个目录多个文件"></a>同一个目录多个文件</h2><p>假如我们有如下的工程目录</p>
<ul>
<li>Demo<ul>
<li>main.cpp</li>
<li>people.cpp</li>
<li>people.h</li>
</ul>
</li>
</ul>
<p>CMakeLists.txt文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cpp people.cpp)</span><br></pre></td></tr></table></figure>
<p>观察发现，我们只是在<code>add_executable()`</code>方法中添加了一个源文件</p>
<p>如果我们只有两三个源文件，这样写完全没有问题，但是通常项目中远不止这几个源文件，这时我们要使用另外一种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure>
<p>上述代码中，    <code>aux_source_directory(.DIR_SRCS)</code> 方法将当前目录下所有源文件名称保存到一个数组中：DIR_SRCS，<br>然后将DIR_SRCS当作参数传递给<code>add_executable()</code>函数。</p>
<blockquote>
<p>${DIR_SRCS} 是shell的变量赋值语法，详情参考  <a href="https://blog.csdn.net/qq_28120673/article/details/82888391" target="_blank" rel="noopener">https://blog.csdn.net/qq_28120673/article/details/82888391</a></p>
</blockquote>
<h2 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h2><p>假如我们有如下目录</p>
<ul>
<li>Demo<ul>
<li>main.cpp</li>
<li>animal<ul>
<li>people.cpp</li>
<li>dog.cpp</li>
<li>dog.h</li>
<li>people.h</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CMakeLists.txt文件如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"></span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo)</span><br><span class="line"></span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"></span><br><span class="line"># 添加 animal子目录</span><br><span class="line">add_subdirectory(animal)</span><br><span class="line"></span><br><span class="line"># 指定生成目标 </span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line"></span><br><span class="line"># 添加链接库--指明该项目需要一个链接库animal链接库在animal文件夹中的CMakeLists.txt文件中定义</span><br><span class="line">target_link_libraries(Demo animal)</span><br></pre></td></tr></table></figure></p>
<p>另外我们还需要在animal目录中添加CMakeLists.txt文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"># 生成链接库</span><br><span class="line">add_library (animal $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参考 <a href="http://www.hahack.com/codes/cmake/" target="_blank" rel="noopener">http://www.hahack.com/codes/cmake/</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/cmake 学习/" data-id="cjv0x6c9y000lq8rwju2l3zfl" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  
    <article id="post-csdn转移/nodejs session的原理" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/28/csdn转移/nodejs session的原理/" class="article-date">
  <time datetime="2019-04-28T12:31:54.329Z" itemprop="datePublished">2019-04-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <!-- Table of Contents -->
        
        <h1 id="nodejs-session的原理"><a href="#nodejs-session的原理" class="headerlink" title="nodejs session的原理"></a>nodejs session的原理</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>HTTP协议是没有状态的，但是很多情况下是需要保存一些信息的。比如在用户登录后再次访问网站，没法判断用户是否已经登陆过。因此在这中情况下，我们需要一种数据结构来保存用户信息。于是Cookies就诞生了。</p>
<p>cookies用于在浏览器段保存用户信息。</p>
<p>cookies的特点如下：</p>
<ul>
<li>保存在客户端浏览器</li>
<li>大小最大为4Kb</li>
<li>如果使用了cookies，访问域名时，浏览器会带上这个域名的cookies</li>
</ul>
<p>但用户每次向服务器提交信息时都会带上Cookis。Coolies的特性非常不好，比如要访问的是服务器上的静态资源，比如图片，改访问并不需要确认用户，然而浏览器还是会发送Cookis给服务器。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Session的作用和Cookie差不多，但是Session是保存在服务器端的。前面提到用户通过Cookie向服务器提交用户信息，服务器拿到用户信息后该怎么验证呢？查询一下数据库？？这样可以实现，但是如果每个用户每次访问都要提交从数据库验证一次，那么将对服务器性能的极大浪费。所以服务器端保存Session用来验证用户身份的合法性。</p>
<p>Session的创建循序</p>
<ol>
<li>生成全局唯一标示符</li>
<li>开辟数据存储空间。一般会在内存中开辟一块空间建立存储Session的数据结构，但是这样会有弊端：系统掉电，那么服务器端的Session将全部丢失。所以一般情况下会将Session保存在数据库或者文件夹中。</li>
<li>将Session的全局唯一标示符发送给客户端。</li>
</ol>
<p>现在的问题是服务器怎么将Session的标示符发送给客户端呢。根据HTTP协议，数据的发送可以放在请求行、头域或Body里。</p>
<p>服务器发送给客户端浏览器Session的唯一标示符保存在客户端的Cookies中。</p>
<h2 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h2><p>服务器返回浏览器的请求中设置Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;Set-Cookie&quot;: &quot;session=r@rdegges.com&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器会返回一个set-cookie的消息，通知浏览器要设置cookie了，于是浏览器会根据set-cookie里的字段来设置信息了，比如上图的信息就会设置<a href="mailto:session=r@rdegges.com" target="_blank" rel="noopener">session=r@rdegges.com</a></p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>现在我们用client-session中间件来配置Session</p>
<ol>
<li><p>安装模块<br><code>var session = require(&#39;client-sessions&#39;);</code></p>
</li>
<li><p>配置session</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.use(session(&#123;</span><br><span class="line">    cookieName: <span class="string">'session'</span>,  </span><br><span class="line">    secret: <span class="string">'random_string_goes_here'</span>, <span class="comment">//一个随机字符串，因为客户端的数据都是不安全的，所以需要进行加密</span></span><br><span class="line">    duration: <span class="number">30</span>*<span class="number">60</span>*<span class="number">1000</span>, <span class="comment">//session的过期时间，过期了就必须重新设置</span></span><br><span class="line">    activeDuration: <span class="number">5</span>* <span class="number">60</span>*<span class="number">1000</span>, <span class="comment">// 激活时间，比如设置为30分钟，那么只要30分钟内用户有服务器的交互，那么就会被重新激活。</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="在Session中保存用户信息"><a href="#在Session中保存用户信息" class="headerlink" title="在Session中保存用户信息"></a>在Session中保存用户信息</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">app.post(<span class="string">'/login'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    User.findOne(&#123;<span class="attr">email</span>:req.body.email&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err,user</span>)</span>&#123; <span class="comment">//数据库中查找改用户</span></span><br><span class="line">        <span class="keyword">if</span>(!user)&#123; <span class="comment">//没有找到</span></span><br><span class="line">            res.render(<span class="string">'login.jade'</span>,&#123;<span class="attr">error</span>:<span class="string">'用户名或密码错误！'</span>&#125;)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(req.body.password == user.password)&#123;</span><br><span class="line">                req.session.user == user <span class="comment">//将user信息保存到Session中</span></span><br><span class="line">                res.redirect(<span class="string">'/dashboard'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res.render(<span class="string">'login.jade'</span>,&#123;<span class="attr">error</span>:<span class="string">'用户名或密码错误!'</span>&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="session层中间件"><a href="#session层中间件" class="headerlink" title="session层中间件"></a>session层中间件</h2><p>我们可以会在对每个请求做如下的检查，但是我们完全可以不必这样做。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.session &amp;&amp; req.session.user)  &#123;</span><br><span class="line">    User.findOne(&#123; <span class="attr">email</span>: req.session.user.email &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, user</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (user) &#123;</span><br><span class="line">        req.user = user;</span><br><span class="line">        <span class="keyword">delete</span> req.user.password; <span class="comment">// delete the password from the session</span></span><br><span class="line">        req.session.user = user;  <span class="comment">//refresh the session value</span></span><br><span class="line">        res.locals.user = user;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// finishing processing the middleware and run the route</span></span><br><span class="line">      next();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果需要是用户登录后才能访问的页面，那么我们可以设计一个检查是否登录的中间函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">requireLogin</span>(<span class="params">req,res,next</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!req.user)&#123;</span><br><span class="line">        res.redirect(<span class="string">'/login'</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        next();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">'/dashboard'</span>,requireLogion,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    res.render(<span class="string">'dashboard.jade)</span></span><br><span class="line"><span class="string">&#125;)</span></span><br></pre></td></tr></table></figure>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><p>我们可以在登出时重置Session</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">'/logout'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">req,res</span>)</span>&#123;</span><br><span class="line">    req.session.reset()</span><br><span class="line">    res.redirect(<span class="string">'/'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Cookie和Session有各自的优缺点</p>
<ol>
<li>应用场景</li>
</ol>
<p>Cookie的典型应用为RememberMe 服务即用户的账户信息通过cookie的形式保存在客户端，当用户再次请求匹配的url时，账户信息会被传送到服务器端，交给相应的程序完成自动登录功能。当然亦可以保存一些客户端信息，如页面布局和搜索历史等。</p>
<p>Session的典型应用场景是用户登录某网站之后，将其登录信息放入session，在以后的每次请求中查询相应的登录信息以确保该用户合法。当然还是有购物车等等经典场景；</p>
<ol start="2">
<li>安全性</li>
</ol>
<p>cookie将信息保存在客户端，如果不进行加密的话，无疑会暴露一些隐私信息，安全性很差，一般情况下敏感信息是经过加密后存储在cookie中，但很容易就会被窃取。而session只会将信息存储在服务端，如果存储在文件或数据库中，也有被窃取的可能，只是可能性比cookie小了太多。</p>
<p>Session安全性方面比较突出的是存在会话劫持的问题，这是一种安全威胁，这在下文会进行更详细的说明。总体来讲，session的安全性要高于cookie；</p>
<ol start="3">
<li>性能</li>
</ol>
<p>Cookie存储在客户端，消耗的是客户端的I/O和内存，而session存储在服务端，消耗的是服务端的资源。但是session对服务器造成的压力比较集中，而cookie很好地分散了资源消耗，就这点来说，cookie是要优于session的；</p>
<ol start="4">
<li>时效性</li>
</ol>
<p>Cookie可以通过设置有效期使其较长时间内存在于客户端，而session一般只有比较短的有效期（用户主动销毁session或关闭浏览器后引发超时）；</p>
<ol start="5">
<li>其他</li>
</ol>
<p>Cookie的处理在开发中没有session方便。而且cookie在客户端是有数量和大小的限制的，而session的大小却只以硬件为限制，能存储的数据无疑大了太多。</p>
<blockquote>
<p>参考<a href="https://segmentfault.com/a/1190000010837077" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010837077</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/28/csdn转移/nodejs session的原理/" data-id="cjv0x6ca4000wq8rwvl7z6r8h" class="article-share-link">分享</a>
      
      
      
    </footer>
  </div>
  
</article>
 


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; 上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">下一页&raquo;</a>
  </nav>
</section>
           
    <aside id="sidebar">
  
    

  
    
  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title recent-posts">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/04/28/csdn转移/js对象/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/记忆化搜索与动态优化与背包问题/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/Fence Repair 栅栏分割/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/贪心算法-Aaruman's Army/">(no title)</a>
          </li>
        
          <li>
            <a href="/2019/04/28/csdn转移/贪心算法分析/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    

  
</aside>

      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-left">
      &copy; 2014 - 2019 wycan&nbsp;|&nbsp;
      主题 <a href="https://github.com/giscafer/hexo-theme-cafe/" target="_blank">Cafe</a>
    </div>
     <div id="footer-right">
      联系方式&nbsp;|&nbsp;1982659010@qq.com
    </div>
  </div>
</footer>
 <script src="/jquery/jquery.min.js"></script>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">首页</a>
  
    <a href="/archives" class="mobile-nav-link">归档</a>
  
    <a href="/about" class="mobile-nav-link">关于</a>
  
</nav>
    <img class="back-to-top-btn" src="/images/fly-to-top.png">
<script>
// Elevator script included on the page, already.
window.onload = function() {
  var elevator = new Elevator({
    selector:'.back-to-top-btn',
    element: document.querySelector('.back-to-top-btn'),
    duration: 1000 // milliseconds
  });
}
</script>
      

  
    <script>
      var cloudTieConfig = {
        url: document.location.href, 
        sourceId: "",
        productKey: "e2fb4051c49842688ce669e634bc983f",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.ws.126.net/f2e/tie/yun/sdk/loader.js"></script>
    

  







<!-- author:forvoid begin -->
<!-- author:forvoid begin -->

<!-- author:forvoid end -->

<!-- author:forvoid end -->


  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      })
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      })
    </script>
    <script type="text/javascript" src="https://cdn.rawgit.com/mathjax/MathJax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


 <script src="/js/is.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/elevator.js"></script>
  </div>
</body>
</html>